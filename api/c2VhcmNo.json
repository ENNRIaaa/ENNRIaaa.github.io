[{"title":"Vue验证表单字段常用规则","date":"2020-09-21T11:18:00.000Z","date_formatted":{"ll":"2020年9月21日","L":"2020/09/21","MM-DD":"09-21"},"updated":"2020-09-21T03:43:24.421Z","content":"项目代码使用的element-ui\n1. 页面表单添加验证属性\n1234&lt;!--el-form中要绑定model;el-form-item绑定prop属性--&gt;&lt;el-form :model=org :rules=&quot;rules&quot;&gt;  &lt;el-form-item label=&quot;xxx&quot; prop=&quot;name&quot;&gt;&lt;/el-form-item&gt;&lt;/el-form&gt;\n\n\nel-form中rules属性对应data()中的rules校验对象\n\n\nel-form-item中prop属性对应的rules对象中的属性\n\n\n2. rules是一个验证规则对象,因此需要在data()页面数据里添加rules对象\n1234rules: &#123;        name: [&#123; required: true, message: this.$t(&#x27;rules.require&#x27;), trigger: &#x27;blur&#x27; &#125;],        password: [&#123; required: true, message: this.$t(&#x27;rules.require&#x27;), trigger: &#x27;blur&#x27; &#125;]&#125;\n3. 创建全局验证规则my-validate.js，供页面灵活引入\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/* 验证账号 */export function validateUsername(rule, value, callback) &#123;  if (value.length &lt; 6 || value.length &gt; 20) &#123;    return callback(new Error(&#x27;用户名不得小于6个或大于20个字符!&#x27;))  &#125; else &#123;    callback()  &#125;&#125; /* 验证密码 */export function validatePassword(rule, value, callback) &#123;  if (value.length &lt; 6) &#123;    return callback(new Error(&#x27;密码不能小于6位&#x27;))  &#125; else &#123;    callback()  &#125;&#125; /* 合法邮箱 */export function validateEmail(rule, value, callback) &#123;  const emailReg = /^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]&#123;2,5&#125;)&#123;1,25&#125;)$/  if (!value) &#123;    return callback(new Error(&#x27;邮箱不能为空!!&#x27;))  &#125;  setTimeout(() =&gt; &#123;    if (!emailReg.test(value)) &#123;      return callback(new Error(&#x27;邮箱格式错误&#x27;))    &#125; else &#123;      callback()    &#125;  &#125;, 100)&#125; /* 合法手机号 */export function validatePhone(rule, value, callback) &#123;  const phoneReg = /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/  if (!value) &#123;    return callback(new Error(&#x27;手机号码不能为空!!&#x27;))  &#125;  setTimeout(() =&gt; &#123;    if (!phoneReg.test(value)) &#123;      return callback(new Error(&#x27;手机号码格式错误&#x27;))    &#125; else &#123;      callback()    &#125;  &#125;, 100)&#125; /* 合法真实姓名 */export function validateRealName(rule, value, callback) &#123;  const realnameReg = /^([a-zA-Z0-9\\u4e00-\\u9fa5\\·]&#123;1,10&#125;)$/  if (!value) &#123;    return callback(new Error(&#x27;真实姓名不能为空!!&#x27;))  &#125;  setTimeout(() =&gt; &#123;    if (!realnameReg.test(value)) &#123;      return callback(new Error(&#x27;您的真实姓名格式错误,请输入英文或汉字!&#x27;))    &#125; else &#123;      callback()    &#125;  &#125;, 100)&#125; /* 合法身份证 */export function validateIdNumber(rule, value, callback) &#123;  const idNumberReg = /^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$|^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$/  if (!value) &#123;    return callback(new Error(&#x27;身份证号码不能为空!!&#x27;))  &#125;  setTimeout(() =&gt; &#123;    if (!idNumberReg.test(value)) &#123;      return callback(new Error(&#x27;您的身份证号码格式错误!&#x27;))    &#125; else &#123;      callback()    &#125;  &#125;, 100)    /** * 校验营业执照注册号/统一社会信用代码 * @param rule * @param value * @param callback */export function validateBusinessLicense(rule, value, callback) &#123;  if (value.length === 15 || value.length === 18) &#123;    if (value.length === 15) &#123;      let ti = 0      let si = 0// pi|11+ti      let cj = 0// （si||10==0？10：si||10）*2      let pj = 10// pj=cj|11==0?10:cj|11      let lastNum = &#x27;&#x27;      for (let i = 0; i &lt; value.length; i++) &#123;        ti = parseInt(value[i])        si = pj + ti        cj = (si % 10 === 0 ? 10 : si % 10) * 2        pj = cj % 11        if (i === value.length - 1) &#123;          // lastNum =(1 - pj &lt; 0 ? 11 - pj : 1 - pj) % 10;          lastNum = si % 10        &#125;      &#125;      if (lastNum === 1) &#123;        callback()      &#125; else &#123;        callback(&#x27;营业执照注册号不正确&#x27;)      &#125;    &#125;    if (value.length === 18) &#123;      var str = &#x27;0123456789ABCDEFGHJKLMNPQRTUWXY&#x27;      var ws = [1, 3, 9, 27, 19, 26, 16, 17, 20, 29, 25, 13, 8, 24, 10, 30, 28]      // eslint-disable-next-line no-array-constructor      var codes = new Array()      codes[0] = value.substr(0, value.length - 1)      codes[1] = value.substr(value.length - 1, value.length)      var sum = 0      for (var i = 0; i &lt; 17; i++) &#123;        sum += str.indexOf(codes[0].charAt(i)) * ws[i]      &#125;      var c18 = 31 - (sum % 31)      if (c18 === 31) &#123;        c18 = &#x27;Y&#x27;      &#125; else if (c18 === 30) &#123;        c18 = &#x27;0&#x27;      &#125;      if (str.charAt(c18) !== codes[1].charAt(0)) &#123;        callback(&#x27;统一社会信用代码不正确&#x27;)      &#125;      callback()    &#125;  &#125; else &#123;    callback(&#x27;号码位数不正确&#x27;)  &#125;&#125;\n4. 引入全局验证脚本\n1import &#123; validateBusinessLicense &#125; from &#x27;@/utils/my-validate&#x27;\n5. 在rules对象中使用引入的校验规则\n1unifyCode: [&#123; required: true, validator: validateBusinessLicense, trigger: &#x27;blur&#x27; &#125;]\n","plink":"https://www.shiguangping.com/2020/09/vue-form-validator/"},{"title":"Docker部署nacos单机版","date":"2020-09-20T00:05:00.000Z","date_formatted":{"ll":"2020年9月20日","L":"2020/09/20","MM-DD":"09-20"},"updated":"2020-09-19T16:07:41.953Z","content":"创建nacos容器\n\n\n搜索镜像\n1docker search nacos\n\n\n拉取镜像到本地（未指定版本默认拉取远程仓库中的最新版）\n1docker pull nacos/nacos-server\n\n\n新建nacos容器\n1docker run --env MODE=standalone --name nacos -d -p 8848:8848 nacos/nacos-server\nenv参数是指容器所处的环境，这里是指建立单机版的nacos\n\n\n配置数据库\n\n\n创建数据库（默认使用mysql数据库）\n1create database nacos_config;\n\n\n导入sql脚本，到官网复制\n\n\n修改nacos配置文件\n1docker exec -it nacos /bin/sh; exit\nnacos为容器名称，进入交互模式，进入conf目录，可以使用vim编辑nacos配置文件application.properties。\n123456# 修改端口号（默认是8848）server.port=8001# 数据库的url/user/passdb.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=123456\ndb.url.1用于配置从数据库，不需要先注释掉\n\n\n以上都配置完之后重启容器，访问http://localhost:8001/nacos，显示登陆页面，用户名和密码默认都是nacos。\n","plink":"https://www.shiguangping.com/2020/09/docker-nacos-standalone/"},{"title":"Vue组件间通信","date":"2020-09-19T21:34:00.000Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-09-20T08:57:15.113Z","content":"Vue组件间通信的两种常见情况：\n\n父子组件间通信\n\n父传子\n子传父\n\n\n非父子组件间通信\n\n\n父子组件间通信：\n父子组件通信很简单，父组件会通过 props 向下传数据给子组件，当子组件有事情要告诉父组件时会通过 $emit 事件告诉父组件。\n这里拿element-ui中的对话框dialog举例，定义两个组件，Index.vue和Dialog.vue。Index中有一个按钮，点击按钮，将dialog.isVisible=true带到子组件中，打开对话框；在子组件中点击关闭按钮，再关闭对话框。关闭时，需要在子组件调用父组件中的方法，将父组件中的属性dialog.isVisible置为false。\nDialog.vue：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt;  &lt;div&gt;    &lt;el-dialog        :title&#x3D;&quot;title&quot;        :visible.sync&#x3D;&quot;isVisible&quot;        width&#x3D;&quot;30%&quot;&gt;      &lt;span&gt;message:&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;    &lt;el-button @click&#x3D;&quot;close&quot; type&#x3D;&quot;primary&quot;&gt;关 闭&lt;&#x2F;el-button&gt;  &lt;&#x2F;span&gt;    &lt;&#x2F;el-dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &quot;dialog&quot;,  &#x2F;&#x2F; props:定义组件的属性，父组件通过props中定义的属性将值传过来。也就是说父组件只能向子组件中props定义的属性传值  props: &#123;    visible: &#123;      type: Boolean,      default: false    &#125;,    title: &#123;      type: String,      default: &#39;&#39;    &#125;  &#125;,  &#x2F;&#x2F; 当组件属性发生改变时返回最新的值  computed: &#123;    isVisible() &#123;      return this.visible    &#125;  &#125;,  data() &#123;    return &#123;      msg: &#39;&#39;    &#125;  &#125;,  methods: &#123;    close() &#123;      &#x2F;&#x2F; 子组件调用父组件方法，定义close事件，当dialog关闭时，调用父组件定义的方法&lt;Dialog @close&#x3D;&quot;xxx&quot;&#x2F;&gt;，调用父组件中的xxx方法      this.$emit(&#39;close&#39;)    &#125;,    &#x2F;&#x2F; 该方法在父组件中通过$refs.dialog.initMsg()的形式调用    initMsg()&#123;      this.msg &#x3D; &#39;父组件调用子组件方法&#39;    &#125;  &#125;&#125;&lt;&#x2F;script&gt;\nIndex.vue：\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt;  &lt;div&gt;    &lt;button @click&#x3D;&quot;dialogOpen&quot;&gt;打开对话框&lt;&#x2F;button&gt;    &lt;!--\t\t\tvisible：是子组件props中定义的属性，父组件通过通过这种形式将值带到子组件中\t\t\ttitle：也是同理\t\t\t@close&#x3D;&quot;dialogClose&quot;：@close是子组件Dialog自定义的事件。当Dialog关闭时，子组件中执行this.$emit(&#39;close&#39;)，调用父组件中的dialogClose()方法\t\t\tref：官方的解释是用来给元素或子组件注册一个引用，该引用会绑定到父组件的$refs对象上。如果在普通DOM元素上使用，引用指向的是DOM元素；如果用在子组件上，引用就是指向子组件的实例。\t\t--&gt;    &lt;Dialog :visible&#x3D;&quot;dialog.isVisible&quot; :title&#x3D;&quot;dialog.title&quot; @close&#x3D;&quot;dialogClose&quot; ref&#x3D;&quot;dialog&quot;&gt;&lt;&#x2F;Dialog&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Dialog from &#39;.&#x2F;components&#x2F;Dialog&#39;export default &#123;  name: &quot;index&quot;,  components: &#123;Dialog&#125;,  data() &#123;    return &#123;      dialog: &#123;        isVisible: false,        title: &#39;&#39;      &#125;    &#125;  &#125;,  methods: &#123;    dialogOpen() &#123;      this.dialog.title &#x3D; &#39;父传子&#39;      &#x2F;&#x2F; 父组件调用子组件方法，通过ref属性指向子组件实例，调用子组件中的方法      this.$refs.dialog.initMsg()      this.dialog.isVisible &#x3D; true    &#125;,    dialogClose() &#123;      this.dialog.isVisible &#x3D; false    &#125;  &#125;&#125;&lt;&#x2F;script&gt;\n非父子组件间通信：\n\n如果我们不需要类似Vuex这样的库来处理组件之间的数据通信，就可以考虑Vue中的 事件总线 ，即 EventBus来通信。\nEventBus的简介\nEventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。\n如何使用EventBus\n一、初始化\n首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来处理。先来看第一种，新创建一个 .js 文件，比如 event-bus.js\n123// event-bus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()\n实质上EventBus是一个不具备 DOM 的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便。\n另外一种方式，可以直接在项目中的 main.js 初始化 EventBus :\n12// main.jsVue.prototype.$EventBus = new Vue()\n注意，这种方式初始化的EventBus是一个全局的事件总线。\n现在我们已经创建了 EventBus ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。\n二、发送事件\n\n假设你有两个Vue页面需要通信： A 和 B ，A页面 在按钮上面绑定了点击事件，发送一则消息，想通知 B页面。\n123456789101112131415&lt;!-- A.vue --&gt;&lt;template&gt;    &lt;button @click&#x3D;&quot;sendMsg()&quot;&gt;-&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; EventBus &#125; from &quot;..&#x2F;event-bus.js&quot;;export default &#123;  methods: &#123;    sendMsg() &#123;      EventBus.$emit(&quot;aMsg&quot;, &#39;来自A页面的消息&#39;);    &#125;  &#125;&#125;; &lt;&#x2F;script&gt;\n接下来，我们需要在 B页面 中接收这则消息。\n三、接收事件\n\n123456789101112131415161718192021&lt;!-- IncrementCount.vue --&gt;&lt;template&gt;  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123; EventBus &#125; from &quot;..&#x2F;event-bus.js&quot;;export default &#123;  data()&#123;    return &#123;      msg: &#39;&#39;    &#125;  &#125;,  mounted() &#123;    EventBus.$on(&quot;aMsg&quot;, (msg) &#x3D;&gt; &#123;      &#x2F;&#x2F; A发送来的消息      this.msg &#x3D; msg;    &#125;);  &#125;&#125;;&lt;&#x2F;script&gt;\n同理我们也可以在 B页面 向 A页面 发送消息。这里主要用到的两个方法：\n12345// 发送消息EventBus.$emit(channel: string, callback(payload1,…))// 监听接收消息EventBus.$on(channel: string, callback(payload1,…))\n前面提到过，如果使用不善，EventBus会是一种灾难，到底是什么样的“灾难”了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus事件监听。\n移除事件监听者\n\n123import &#123; eventBus &#125; from &#x27;./event-bus.js&#x27;EventBus.$off(&#x27;aMsg&#x27;, &#123;&#125;)\n你也可以使用 EventBus.$off('aMsg') 来移除应用内所有对此某个事件的监听。或者直接调用 EventBus.$off() 来移除所有事件频道，不需要添加任何参数 。\n上面就是 EventBus 的使用方法，是不是很简单。上面的示例中我们也看到了，每次使用 EventBus 时都需要在各组件中引入 event-bus.js 。事实上，我们还可以通过别的方式，让事情变得简单一些。那就是创建一个全局的 EventBus 。接下来的示例向大家演示如何在Vue项目中创建一个全局的 EventBus 。\n全局EventBus\n它的工作原理是发布/订阅方法，通常称为 Pub/Sub 。\n创建全局EventBus\n123456789var EventBus = new Vue();Object.defineProperties(Vue.prototype, &#123;  $bus: &#123;    get: function () &#123;      return EventBus    &#125;  &#125;&#125;)\n在这个特定的总线中使用两个方法$on和$emit。一个用于创建发出的事件，它就是$emit；另一个用于订阅$on：\n1234567var EventBus = new Vue();this.$bus.$emit(&#x27;nameOfEvent&#x27;, &#123; ... pass some event data ...&#125;);this.$bus.$on(&#x27;nameOfEvent&#x27;,($event) =&gt; &#123;  // ...&#125;)\n然后我们可以在某个Vue页面使用this.$bus.$emit(&quot;sendMsg&quot;, '我是web秀');，另一个Vue页面使用\n123this.$bus.$on(&#x27;updateMessage&#x27;, function(value) &#123;  console.log(value); // 我是web秀&#125;)\n同时也可以使用this.$bus.$off('sendMsg')来移除事件监听。\n总结\n本文主要通过简单的实例学习了Vue中有关于 EventBus 相关的知识点。主要涉及了 EventBus 如何实例化，又是如何通过 $emit 发送频道信号，又是如何通过 $on 来接收频道信号。最后简单介绍了如何创建全局的 EventBus 。从实例中我们可以了解到， EventBus 可以较好的实现兄弟组件之间的数据通讯。\n","plink":"https://www.shiguangping.com/2020/09/vue-components-communication/"},{"title":"使用Spring Cloud Feign上传文件","date":"2020-09-06T23:00:00.000Z","date_formatted":{"ll":"2020年9月6日","L":"2020/09/06","MM-DD":"09-06"},"updated":"2020-09-20T08:57:58.748Z","content":"使用Spring Cloud Feign上传文件，早期的Spring Cloud中，Feign本身是没有上传文件的能力的，要想实现这一点，需要自己编写Encoder去实现上传。现在，Feign官方提供了子项目feign-form，其中实现了上传所需的Encoder。\n\n\n注：笔者测试的版本是Edgware.RELEASE。Camden、Dalston同样适应本文所述。\n\n加依赖\n12345678910&lt;dependency&gt;  &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;  &lt;artifactId&gt;feign-form&lt;/artifactId&gt;  &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;  &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;  &lt;version&gt;3.0.3&lt;/version&gt;&lt;/dependency&gt;\n编写Feign Client\n123456789101112131415@FeignClient(name = &quot;ms-content-sample&quot;, configuration = UploadFeignClient.MultipartSupportConfig.class)public interface UploadFeignClient &#123;    @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST,            produces = &#123;MediaType.APPLICATION_JSON_UTF8_VALUE&#125;,            consumes = MediaType.MULTIPART_FORM_DATA_VALUE)    @ResponseBody    String handleFileUpload(@RequestPart(value = &quot;file&quot;) MultipartFile file);    class MultipartSupportConfig &#123;        @Bean        public Encoder feignFormEncoder() &#123;            return new SpringFormEncoder();        &#125;    &#125;&#125;\n如代码所示，在这个Feign Client中，我们引用了配置类MultipartSupportConfig，在MultipartSupportConfig中，我们实例化了SpringFormEncoder。这样这个Feign Client就能够上传了。\n注意点：\n\n\n@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST,\n            produces = &#123;MediaType.APPLICATION_JSON_UTF8_VALUE&#125;,\n            consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n\n这里的produces、consumes不能少；\n\n\n方法参数列表中的注解@RequestPart(value = &quot;file&quot;)不能写成@RequestParam(value = &quot;file&quot;)；\n\n\n最好将Hystrix的超时时间设长一点，例如5秒，否则可能文件还没上传完，Hystrix就超时了，从而导致客户端侧的报错。\n\n\n","plink":"https://www.shiguangping.com/2020/09/feign-upload/"},{"title":"IDEA中的Web项目移动到Eclipse","date":"2020-06-01T22:19:00.000Z","date_formatted":{"ll":"2020年6月1日","L":"2020/06/01","MM-DD":"06-01"},"updated":"2020-09-19T13:26:09.584Z","content":"1. 在IDEA中，打开模块设置：\n\n在模块设置中，将依赖存储格式改为Eclipse：\n\n2. 在Eclipse中导入项目：（File–&gt;Import）\n\n下一步，然后选择项目路径，完成导入：\n\n3. 修改项目相关设置，勾选成动态Web模块\n项目右键–&gt;properties中：\n\n4. 缺少Tomcat依赖：\n完成上述步骤之后，发现Servlet类中跟Servlet有关的代码报错，则大概是因为缺少Tomcat依赖导致的。此时，通过项目build path config中添加Tomcat库即可：\n\n完成上述步骤之后，把项目Add到Tomcat容器中，运行Tomcat，此时项目应该可以正常跑起来了~\n\n@Author liyan\n@blog shiguangping.com\n@Date 2020-6-1\n","plink":"https://www.shiguangping.com/2020/06/ideaproj-to-eclipse/"},{"title":"Mac OS下安装和配置Maven","date":"2020-05-11T14:52:00.000Z","date_formatted":{"ll":"2020年5月11日","L":"2020/05/11","MM-DD":"05-11"},"updated":"2020-09-19T16:09:31.404Z","content":"1. 下载Maven\n\n\n打开Maven官方下载网页：http://maven.apache.org/download.cgi\n\n\n\n解压下载的压缩包放到自己喜欢的目录下，（放到一个固定的目录，不要随意改动）\n比如：/Users/liyan/Documents/CodeRepositorise/apache-maven-3.6.3\n\n\n\n2. 配置环境变量\n\n\n打开终端，输入一下命令：\n1open ~/.bash_profile\n打开.bash_profile文件，添加环境变量：\n12export M2_HOME&#x3D;&#x2F;Users&#x2F;liyan&#x2F;Documents&#x2F;CodeRepositorise&#x2F;apache-maven-3.6.3export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin \n\n添加好之后保存并退出，执行下面的命令使配置生效：\n1source ~/.bash_profile\n\n\n3. 查看配置是否生效\n\n\n在终端输入命令：\n1mvn -v\n\n到这里，Maven配置成功\n\n\n","plink":"https://www.shiguangping.com/2020/05/macos-maven/"},{"title":"设置eclipse格式化时不对注释进行格式化","date":"2020-04-26T15:12:00.000Z","date_formatted":{"ll":"2020年4月26日","L":"2020/04/26","MM-DD":"04-26"},"updated":"2020-09-19T13:24:19.868Z","content":"1. 设置保存时自动格式化\n\n2. 自建代码格式化风格\n我用的工具是STS，自带三种代码格式化风格文件；\n\n这三种风格是不能编辑的，所以我们需要new，自建风格。\n\n\n自建的风格名字自定义\n自建风格可以选择系统自带的默认的风格样式\n\n3. 格式化时不对注释进行格式化\n\nEdit编辑刚刚新建的风格，在Comments，即把上图中红框内的两个勾选框勾掉，取消对文档注释和块注释的格式化。\n格式化的其它功能可以自行尝试\n","plink":"https://www.shiguangping.com/2020/04/eclipse-format-code/"},{"title":"阶段性学习笔记","date":"2020-04-21T21:10:00.000Z","date_formatted":{"ll":"2020年4月21日","L":"2020/04/21","MM-DD":"04-21"},"updated":"2020-09-19T13:06:50.892Z","content":"目录：\n\nJava学习笔记-随着学习进度持续更新\nThymeleaf入门教程，作者waylau\nJava面试题汇总，原文作者小杰要吃蛋，背题过程中我又添加了部分内容\n\n\n其他笔记正在整理当中\n","plink":"https://www.shiguangping.com/2020/04/java-note/"},{"title":"eclipse实现自动补全","date":"2020-04-21T15:07:00.000Z","date_formatted":{"ll":"2020年4月21日","L":"2020/04/21","MM-DD":"04-21"},"updated":"2020-09-19T16:07:55.235Z","content":"eclipse设置自动补全：\n\nWindow -&gt; Preference中：\n\n按照上图红框修改，将Auto activation triggers for Java的值成：.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ，并将Auto activation delay的值改为200。\n","plink":"https://www.shiguangping.com/2020/04/eclipse-auto-completion/"},{"title":"Java编译运行时报错尝试解决办法","date":"2020-04-20T18:02:00.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-09-19T13:30:01.514Z","content":"&quot;Description Resource Path Location Type Java compiler level does not match the version of&quot;解决办法\nproject编译问题，需要有三处的jdk版本保持一致，才能编译通过。\n\n\n在右键项目–&gt;properties–&gt;project Facets–&gt;修改右侧Java的version，要与当前项目jdk版本保持一致\n\n\n\n设置选项preference–&gt;java–&gt;Compiler–&gt;设置的右侧的Compiler compliance level\n\n这一步有的时候不匹配也能编译运行通过\n\n\npreferences–&gt;java–&gt;Installed JREs–&gt;设置或者选择右侧的Installed JREs\n\n这里就是jre环境路径\n\n\n说明：\n这个报错的解决办法，首先检查前两步骤，第一步骤修改完之后会解决当前项目的报错问题，程序可以正常编译运行，但是再新建项目之后，任然会出现该问题；第二步骤修改完之后，可以解决新项目报错问题，避免每次新建项目都需要手动去修改第一步骤；第三步就是当前jdk的开发环境，这个一般都没问题。\n","plink":"https://www.shiguangping.com/2020/04/java-compile-error/"},{"title":"Linux下的Vim使用教程","date":"2020-04-11T00:00:00.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2020-09-19T13:32:41.905Z","content":"什么是Vim？\nVim是从Vi发展出来的一个功能非常强大的文本编辑器，在程序员中广泛使用。\nVim/Vi的使用\n基本上Vim/Vi共分为三种模式：分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是：\n命令模式：\n用户进入Vim时即是命令模式。\n输入模式：\n在命令模式下按 **“ i ”**进入输入模式。\n输入模式下按**“ ESC ”**，退出到命令模式。\n底线命令模式：\n在命令模式下按**“ ：“**（英文状态下的冒号），进入底线命令模式。\n在底线命令模式下可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按**” ESC “ ** 键退出底线命令模式。\nVim工作模式：\nvim filename进入命令模式\ni进入输入模式\nesc退出到命令模式\n:命令模式下按冒号进入到底线命令模式\n:wq保存并退出Vim\n常见命令：\n","plink":"https://www.shiguangping.com/2020/04/vim-help/"},{"title":"L2TP/IPSec一键安装脚本","date":"2020-03-12T21:00:00.000Z","date_formatted":{"ll":"2020年3月12日","L":"2020/03/12","MM-DD":"03-12"},"updated":"2020-09-19T13:31:15.128Z","content":"本脚本适用环境：\n系统支持：CentOS6+，Debian7+，Ubuntu12+\n内存要求：≥128M\n更新日期：2017 年 05 月 28 日\n关于本脚本：\n名词解释如下\nL2TP（Layer 2 Tunneling Protocol）\nIPSec（Internet Protocol Security）\nIKEv2 (Internet Key Exchange v2)\n能实现 IPsec 的目前总体上有 openswan，libreswan，strongswan 这3种。\nlibreswan 是基于 openswan 的 fork，所以现在各个发行版基本已经看不到 openswan 的身影了。\n当然也有使用 strongswan 的。\n之所以要更新 L2TP 一键安装脚本，是因为随着各个 Linux 发行版不断推陈出新，原有的脚本已经不适应现在的需求。\n本脚本通过编译安装最新版 libreswan 来实现 IPSec（CentOS7 下则是全部 yum 安装），yum 或 apt-get 来安装 xl2tpd，再根据各个发行版的使用方法不同，部署防火墙规则。\n写在前面：\n基于 OpenVZ 虚拟化技术的 VPS 需要开启TUN/TAP才能正常使用，购买 VPS 时请先咨询服务商是否支持开启 TUN/TAP。\nOpenVZ 虚拟的 VPS 需要系统内核支持 IPSec 才行。也就是说，母服务器的内核如果不支持的话那就没办法，只能换 VPS。\n因此，一般不建议在 OpenVZ 的 VPS 上安装本脚本。脚本如果检测到该 VPS 为 OpenVZ 架构，会出现警告提醒。\n如何检测是否支持TUN模块？\n执行命令：\ncat /dev/net/tun\n如果返回信息为：\ncat: /dev/net/tun: File descriptor in bad state\n说明正常\n如何检测是否支持ppp模块？\n执行命令：\ncat /dev/ppp\n如果返回信息为：cat: /dev/ppp: No such device or address 说明正常\n当然，脚本在安装时也会执行检查，如果不适用于安装，脚本会予以提示。\n使用方法：\nroot 用户登录后，运行以下命令：\n123wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;across&#x2F;master&#x2F;l2tp.shchmod +x l2tp.sh.&#x2F;l2tp.sh\n执行后，会有如下交互界面\n\nPlease input IP-Range:\n(Default Range: 192.168.18):\n输入本地IP段范围（本地电脑连接到VPS后给分配的一个本地IP地址），直接回车意味着输入默认值192.168.18\nPlease input PSK:\n(Default PSK: teddysun.com):\nPSK意为预共享密钥，即指定一个密钥将来在连接时需要用到，直接回车意味着输入默认值teddysun.com\nPlease input Username:\n(Default Username: teddysun):\nUsername意为用户名，即第一个默认用户。直接回车意味着输入默认值teddysun\nPlease input teddysun’s password:\n(Default Password: Q4SKhu2EXQ):\n输入用户的密码，默认会随机生成一个10位包含大小写字母和数字的密码，当然你也可以指定密码。\nServerIP:your_server_main_IP\n显示你的 VPS 的主 IP（如果是多 IP 的 VPS 也只显示一个）\nServer Local IP:192.168.18.1\n显示你的 VPS 的本地 IP（默认即可）\nClient Remote IP Range:192.168.18.2-192.168.18.254\n显示 IP 段范围\nPSK:teddysun.com\n显示 PSK\nPress any key to start…or Press Ctrl+c to cancel\n按下任意按键继续，如果想取消安装，请按Ctrl+c键\n安装完成后，脚本会执行 ipsec verify 命令并提示如下：\n123456789101112131415If there are no [FAILED] above, then you can connect to yourL2TP VPN Server with the default Username&#x2F;Password is below:ServerIP:your_server_IPPSK:your PSKUsername:your usenamePassword:your passwordIf you want to modify user settings, please use command(s):l2tp -a (Add a user)l2tp -d (Delete a user)l2tp -l (List all users)l2tp -m (Modify a user password)Welcome to visit https:&#x2F;&#x2F;teddysun.com&#x2F;448.htmlEnjoy it!\n如果你要想对用户进行操作，可以使用如下命令：\nl2tp -a 新增用户\nl2tp -d 删除用户\nl2tp -m 修改现有的用户的密码\nl2tp -l 列出所有用户名和密码\nl2tp -h 列出帮助信息\n其他事项：\n1、脚本在安装完成后，已自动启动进程，并加入了开机自启动。\n2、脚本会改写 iptables 或 firewalld 的规则。\n3、脚本安装时，会即时将安装日志写到 /root/l2tp.log 文件里，如果你安装失败，可以通过此文件来寻找错误信息。\n使用命令：\nipsec status （查看 IPSec 运行状态）\nipsec verify （查看 IPSec 检查结果）\n/etc/init.d/ipsec start|stop|restart|status （CentOS6 下使用）\n/etc/init.d/xl2tpd start|stop|restart （CentOS6 下使用）\nsystemctl start|stop|restart|status ipsec （CentOS7 下使用）\nsystemctl start|stop|restart xl2tpd （CentOS7 下使用）\nservice ipsec start|stop|restart|status （Debian/Ubuntu 下使用）\nservice xl2tpd start|stop|restart （Debian/Ubuntu 下使用）\n更新日志\n2017 年 05 月 28 日：\n升级 libreswan 到版本 3.20。\n修正 libreswan 的若干配置问题。\n修正 xl2tpd 的端口监听配置问题。\n修正在 CentOS 6 对 libevent2 的依赖问题，改为 yum 安装 libevent2-devel。\n测试表明，在内网环境的 VPS 里（如AWS， IDCF，GCE，腾讯云，阿里云等）也可以正常使用了。\n2017 年 02 月 25 日：\n升级 libreswan 到版本 3.19。\n2016 年 09 月 12 日：\n修正了在 CentOS 6 下 libevent2 依赖的问题；\n新增了一个 -m 选项，用以修改现有用户的密码。\n2016 年 08 月 13 日：\n修正 Debian 8 下的 sd-daemon.h: No such file or directory 问题，是由于缺少依赖包 libsystemd-daemon-dev 导致的。\n2016 年 08 月 05 日：\n升级 libreswan 到版本 3.18。\n2016 年 06 月 10 日：\n脚本在安装完成后，新增了几个命令，便于操作用户\nl2tp -a 新增用户\nl2tp -d 删除用户\nl2tp -l 列出所有用户\nl2tp -h 列出帮助信息\n2016 年 04 月 25 日：\n4、在 Vultr 的 Debian 7的系统模板下安装时，软件包 libcurl4-nss-dev 会出现依赖错误。如下所示：\n123The following packages have unmet dependencies:libcurl4-nss-dev : Depends: libldap2-dev but it is not going to be installedDepends: librtmp-dev but it is not going to be installed\n而 libldap2-dev 和 librtmp-dev 又依赖了其他几种软件包。总之最后的依赖关系如下：\n1234libldap2-dev : Depends: libldap-2.4-2 (&#x3D; 2.4.31-2+deb7u1) but 2.4.31+really2.4.40+dfsg-1+deb8u1~bpo70+1 is to be installedlibrtmp-dev : Depends: libgnutls-dev but it is not going to be installedlibgnutls-dev : Depends: libp11-kit-dev (&gt;&#x3D; 0.4) but it is not going to be installedlibp11-kit-dev : Depends: libp11-kit0 (&#x3D; 0.12-3) but 0.20.7-1~bpo70+1 is to be installed\n那么解决办法就是把最底层的依赖包 libp11-kit0 先卸载掉，然后再安装 libcurl4-nss-dev 即可。\n12apt-get -y remove libp11-kit0apt-get -y --no-install-recommends install libcurl4-nss-dev wget\n然后再运行脚本安装即可。\n2016 年 04 月 22 日：\n修复了在 Ubuntu 16.04 下因为默认缺少 python 命令而导致 ipsec verify 等命令不能用的问题。\n2016 年 04 月 19 日：\n修复了在 Debian 7 下因为 libnss3 和 libnspr4 的版本过低而导致编译 libreswan 失败的问题。\n2016 年 04 月 18 日：\n目前在 Debian 7 上测试的结果，因为 libnss3 和 libnspr4 的版本过低而导致编译 libreswan 失败。临时解决办法是 dpkg 安装 libnss3_3.17.2 和 libnspr4_4.10.7 的 deb 包后重试。\n\n本内容来源于：https://teddysun.com/448.html\n","plink":"https://www.shiguangping.com/2020/03/l2tp/"},{"title":"入手日版Nintendo Switch","date":"2020-01-29T12:49:00.000Z","date_formatted":{"ll":"2020年1月29日","L":"2020/01/29","MM-DD":"01-29"},"updated":"2020-09-19T13:33:32.718Z","content":"\n这是我入手的第三台任天堂switch。\n第一台是任天堂刚发布switch不久之后购入的，当时系统还没有简体中文，大多数游戏都没有中文，后来闲鱼出手了。\n第二台是去年吧，被异度之刃2这款游戏的CG吸引了，玩了没多久也卖了。\n前几天一直在为入手NS还是NSL所困扰，后来合计一步到位，以后能在电视上玩，还是买了这台Switch，好像是日版的续航增强版，现在版本真多。\n机器是昨天到的，贴膜是今天上午到的。\n刚刚贴膜的时候膜贴废了，随后又在京东买了张贴膜，还有内存卡，打算明天再重新贴一下。\n最近这几天，在家躲避疫情，重新开始玩玩之前的神作，塞尔达旷野之息。\n之前玩的是日文版的，真心费劲。\n","plink":"https://www.shiguangping.com/2020/01/Nintendo-Switch/"},{"title":"退烧键盘-Niz micro82 45g","date":"2019-12-14T14:53:00.000Z","date_formatted":{"ll":"2019年12月14日","L":"2019/12/14","MM-DD":"12-14"},"updated":"2020-09-19T16:10:12.981Z","content":"今天提前收到小姐姐送的生日礼物，一把心仪已久的键盘，Niz宁芝静电容键盘（micro82 45g)。\n废话不多说了，上图：\n（这手感和声音，爽~）\n小姐姐说这个键盘按起来像以前上微机课的键盘-。-！\n\n外包装比较简单\n\n键盘本体，这款是82键版本，白灰的键帽配色，很有敲敲敲的欲望。\n键盘自带了Mac键帽可以替换，还带了几个增压弹簧。\n键盘采用PBT键帽，用久了也不会出现打油的情况。键盘我还是推荐白色，或者类似白色，干净不易脏，看久了不腻。黑色尤其是ABS键帽，特别不耐脏。\n\nNiz的logo。\n键盘有些地方有毛边，但也对得起它的价格。和动辄2000多的HHKB比起来，这款键盘的价格相当亲民了。\n\n感谢小姐姐，2019年12月14日。\n","plink":"https://www.shiguangping.com/2019/12/keyboard-niz/"},{"title":"与铁蛋儿的“一夜情”","date":"2019-09-16T21:20:00.000Z","date_formatted":{"ll":"2019年9月16日","L":"2019/09/16","MM-DD":"09-16"},"updated":"2020-09-19T13:23:35.094Z","content":"铁蛋儿是我昨天晚上捡回来的。\n昨晚在楼下电影院看完郭森斯坦森和巨石强森主演的《速度与激情：特别行动》后回来，在楼下看见了铁蛋儿。\n刚看见铁蛋儿时以为是只野猫，因为小区里的野猫特别多，但是小区的野猫都不近人。铁蛋儿看见我之后，走到我腿边儿蹭，我猜它是饿了。\n随后我就把它勾引回家了。\n回到家我给它水，火腿，吃完东西后给它洗澡，洗澡时有点儿抗拒*（猫咪果然天生不喜欢水）*。\n看它傻头傻脑的样儿，给它取了名字叫铁蛋儿，感觉特配它的傻气。\n\n（今早儿拍的照片，还把以前买的一直没机会戴的猫铃铛给它戴上了）\n当天晚上我到客厅窗边打电话，它就跟着我到了客厅窗台上站着，一动不动。\n我回卧室躺着，它也屁颠儿屁颠儿地跑到床上，过一会儿就在我身边睡着了，伴随着猫咪特有的呼噜声。\n期间它醒了几次，不一会儿又睡着了。\n\n我在床上躺着开始上网查如何养猫，养猫要注意什么？怎么才能不让它破坏家里面的东西，内心纠结着能不能对它的一生付责任。\n早晨起来发现它在我家门口旁的袋子上尿尿了，估计是当成猫砂了。我猜铁蛋儿是有主人的。\n结果今早儿，铁蛋儿的主人就在小区群里发了寻猫启事。\n虽然对铁蛋儿有很多的不舍，但我还是联系了铁蛋儿真正的主人。\n与其我模棱两可的纠结是否收养它，不如把它交给真正对它好的主人身边吧。\n我和铁蛋儿的“一夜情”就这样结束了。\n从主人处得知，铁蛋儿是一只约三个多月大的小母猫。\n铁蛋儿の写真\n\n\n\n","plink":"https://www.shiguangping.com/2019/09/cat-tiedar/"},{"title":"使用Cloudreve搭建私有云盘","date":"2019-09-09T22:10:00.000Z","date_formatted":{"ll":"2019年9月9日","L":"2019/09/09","MM-DD":"09-09"},"updated":"2020-09-19T13:23:57.796Z","content":"1.访问官网下载源码\n\n下载最新的安装包\n\n2.解压缩并将源码上传至服务器空间\n将下载好的安装包解压后，将文件夹内的所有文件全部上传至服务器空间\n\n3.访问域名导入数据库安装\n源码上传至空间后，浏览器访问域名/CloudreveInstaller进行环境检查，配置数据库信息。\n4.登录后台配置相关设置\n安装完成后，访问【您的域名/admin】，登录到后台，可修改用户名密码，以及配置所需要的设置等\n\n5.遇到的问题\n\n头像显示问题，上传头像不显示，可能是服务器PHP没有安装【fileinfo】插件。我用的bt面板，在PHP的安装扩展里安装fileinfo即可。\n不支持文件夹上传，这个不算是问题，我看论坛，开发者目前没有加入文件夹上传这一功能。\n\n","plink":"https://www.shiguangping.com/2019/09/cloudreve/"},{"title":"根据转载的一篇文章总结的Java学习方法","date":"2018-06-17T23:19:26.000Z","date_formatted":{"ll":"2018年6月17日","L":"2018/06/17","MM-DD":"06-17"},"updated":"2020-09-19T16:10:38.306Z","content":"step 1 学习路线\n路线：JavaSE–&gt;web–&gt;Java后端\n1. JavaSE\n找一个Java基础教程，尽量多动手，对Java有一个基本的了解。\n2. web开发\n学习web，学习顺序：\n\n\nHTML/CSS/JS\n\n\nServlet/JSP(JAVAEE)\n\n\nMysql(数据库)\n\n\n\n\n首先，要学习HTML/CSS/JS，这些东西对于Java后端开发来说，理论上不是特别重要，但至少要达到可以自己写页面的水平。\n\n\n然后，**Servlet/JSP(JAVAEE)**这部分，这部分是Java后端必须必须精通的，这部分也是三部分中最需要花费精力的。\n\n\n最后，学习使用数据库，Mysql是不错的入门选择，而且Java领域主流的关系型数据库就是Myqsl。这部分一般在学习Servlet/JSP的时候就会接触到，其中JDBC部分就是数据库的相关部分。这部分不仅要学会用JDBC操作数据库，还要学会使用数据库客户端工具，例如：navicat，sqlyog，二选一即可.\n\n\n3. 开发框架\n学会以上内容还不足以参加工作，为了提高开发效率，会使用一些Java Web框架。目前比较主流的是SSM框架，即spring，springmvc，mybatis。这里需要学会这三种框架的搭建，并用他们做出一个简单的增删改查项目.\n快速地利用SSM搭建出一个web框架是必须的，记录下第一次的搭建过程是很有必要的。在搭建SSM的过程中，会接触到一个叫maven的工具，这个工具是以后工作当中会经常用到的工具。在目前这个阶段，只需要到网上了解一下maven的基本用法即可，更高端的用法会随着工作经验的增加，逐渐接触到的。\n4. 找工作\n当完成开发框架的学习以后，就该找工作了。在找工作的同时，不应该停下学习。上面这些内容只是囫囵吞枣的学会了使用，你可以逐步尝试着去了解更多的东西，网络是你最重要的老师。\nstep 2 Java编程思想,深入理解Java基础\n对于参加工作___1年以内___的同学，恭喜你，这个时候，你已经拥有了一份Java的工作。这个阶段是你成长极快的阶段，而且你可能会经常加班。但是加班不代表你就可以松懈了，永远记得我说的那句话，从你入行那一刻起，你就要不停的学习。\n在这一年里，你至少需要看完**《Java编程思想》**这本书。这本书的内容是帮助你对于Java有一个更加深入的了解，是Java基础的升级版。这本书很厚，当初看这本书，我花了整整三个月。正常速度的话，应该可以在半年左右看完。我这里不要求过高，只要你在一年以内把这本书看完即可。当然了，我所说的看完，是充分吸收，而不是读一遍就完事了，因此有些内容你可能会看不止一遍。总而言之，这个阶段的核心学习思想就是，在工作中实践，并且更加深入的了解Java基础。\n设计模型\n对于参加工作1年到2年的同学，这部分时间段的同学，已经对Java有了一个更加深入的了解。但是对于面向对象的体会可能还不够深刻，编程的时候还停留在完成功能的层次，很少会去考虑设计的问题。于是这个时候，设计模式就来了。我当时看的是**《大话设计模式》**这本书，并且写了完整版的设计模式博客。因此，我要求大家，最多在你工作一年的时候，必须开始写博客，而设计模式就是你博客的开端。\n请记住，我所提的基本都是最低要求，因此不要有任何松懈的心理，否则五年后，你不要去羡慕别人高于你的工资，也不要去羡慕别人进入了某公司。这一年，你必须对于设计模式了如指掌，《大话设计模式》可以作为你的开端。此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。比如**《重构 改善既有代码的设计》，《effective java》**。总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。\nstep 3 参加工作2年到3年的同学\n对于参加工作2年到3年的同学，有的同学在这个时候觉得自己已经很牛逼了，于是忍不住开始慢慢松懈.请记住,你还嫩的多。对这个阶段，有一本书是你必须看的，它叫做**《深入理解Java虚拟机》**。这本书绝对是Java开发者最重要的书，没有之一。在我眼里，这本书的重要性还要高于《Java编程思想》。这本书的内容是帮助你全面的了解Java虚拟机，在这个阶段，你一定已经知道Java是运行在JVM之上的。所以，对于JVM，你没有任何理由不了解它。\n另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，而这部分内容，我比较推荐**《Java并发编程实战》**这本书。只要你把这本书啃下来了，并发的部分基本已经了解了十之六。与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。\n因此，你需要去看一些jdk中的类的源码，也包括你所使用的框架的源码。这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写？为什么要定义这个接口，它看起来好像很多余？由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且我很负责的告诉你，我在这个阶段的时候，所学习的东西远多于这里所罗列出来的。\n因此千万不要觉得你已经学的很多了，我所说的这些都只是最低要求，不光是我，很多人在这个时间段所学习的内容都远超本文的范围。如果你不能跟上节奏的话，若干年后，如果不是程序猿市场还不错的话，你很可能不仅仅是工资比别人低，公司没别人好，而是根本就找不到工作。总而言之，这个阶段，你需要做的是深入了解Java底层和Java类库（比如并发那本书就是Java并发包java.concurrent的内容），也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。另外，还有一种学习的方式，在2年这个阶段，也应该启用了，那就是造轮子。不要听信那套“不要重复造轮子”的论调，那是公司为了节省时间成本编造出来的。重复造轮子或许对别人没有价值，因为你造的轮子可能早就有了，而且一般情况下你造出来的轮子还没有现存的好。\n但是对别人没有价值，不代表对你自己没有价值。一个造轮子的过程，是一个从无到有的过程。这个过程可以对你进行系统的锻炼，它不仅考察你的编码能力，还考察你的框架设计能力，你需要让你的轮子拥有足够好的扩展性、健壮性。而且在造轮子的过程中，你会遇到各种各样的难题，这些难题往往又是你学习的契机。当你把轮子造好的时候，你一定会发现，其实你自己收获了很多。所以，这个阶段，除了上面提到的了解JVM/JDK和框架源码以外，也请你根据别人优秀的源码,去造一个任何你能够想象出来的轮子。\nstep 4 参加工作3年到4年的同学\n对于参加工作3年到4年的同学，这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。而且在研究一门新技术时，切忌朝三暮四。有的同学今天去整整大数据，搞搞Hadoop/hbase一类的东西。过不了一段时间，就觉得没意思，又去研究分布式缓存，比如redis。然后又过不了一段时间，又去研究分布式计算，比如整整Mapreduce或者storm。结果到最后，搞得自己好像什么都会一样，在简历上大言不惭的写上大数据、分布式缓存、分布式计算都了解，其实任何一个都只是浮于表面。到时候面试官随便一问，就把你给识破了。\n一定要记住，作为一个程序猿，平日里所接触的技术可能会很多，但是想要让一门技术成为你的优势，那么一定是你对这门技术的了解强过绝大多数人才行。因此在这个阶段，你就不能再简单的去学习前3年的内容了，虽然前面的学习如果还不够深入的话依旧要继续，但这个时候你应该更多的考虑建立你的优势，也可以称为差异性。差异性相信不难理解，就是让你自己变得与众不同。你前面三年的学习足够你成为一名基本合格的Java开发者，但你离成为一名优秀的Java开发者还有很大的距离。\n所谓优秀，即能别人所不能。而你前三年所学习的内容，是很多做过几年的Java开发都能够掌握的。那么为了让自己有差异性，你就需要另辟蹊径，找一个方向深入研究下去，以期在将来，你能够成为这个领域的专家，比如分布式计算领域的专家，大数据领域的专家，并发领域的专家等等。此外，你除了建立你的差异性之外，还要去弥补你基础上的不足，直到现在，我都没有提及基础知识。原因是基础是很枯燥无味的，学的太早不仅容易懵逼，而且懵逼的同时还容易产生心理阴影，以至于以后再不想去研究这些基础。但基础又是你深入研究一些领域时所必须掌握的，比如你去研究分布式计算，你不懂算法你玩个毛？比如你去做分布式缓存，你对计算机系统的内存不了解，你如何去做缓存？\n如果你的基础本来就非常强，那么恭喜你，相信你在之前的工作中已经充分体会到了这些基础对你的帮助。但我相信大部分人的基础都很薄弱，哪怕是科班毕业的人，很多人也不敢说自己当初的基础学的多么强大，比如算法、计算机系统原理、编译原理这些。但是每个人时间都是有限的，而且这些基础的书籍每一本读下来，没个一年半载的，还真拿不下来，因此还是要有所抉择的。虽然艺多不压身，但问题是艺多是有代价的，是需要你付出时间和精力的，而我个人更赞成在同等代价的情况下获取最大的收获。\n首先，我比较推崇的基础书籍有三本，分别是**《深入理解计算机系统》，《tcp/ip详解 卷一、二、三》，《数据结构与算法》**。其中TCP/IP有三本书，但我们这里把这三本看成是一本大书。这三本分别适合三种人，《深入理解计算机系统》比较适合一直从事Java Web开发和APP后端开发工作的人群。《tcp/ip详解 卷一、二、三》比较适合做网络编程的人群，比如你使用netty去开发的话，那么就要对TCP/IP有更深入的了解。而《数据结构与算法》这本书，则比较适合做计算研究工作的人，比如刚才提到的分布式计算。另外，我要强调的是，这里所说的适合，并不是其它两本对你就没有用。比如你做Java Web和APP后端开发，《tcp/ip详解 卷一、二、三》这本书对你的作用也是很大的。这里只是分出个主次关系而已，你要是时间足够的话，能把三本都精读那当然最好不过了。\n但如果时间有限的话，那么就先挑对你帮助最大的书去读。理论上来讲，这一年你能把这三本其中一本精读下来，就已经非常厉害了。有了基础，有了前面的工作经验，你就可以去开拓属于你的领域了。在这一年里，一定要规划好自己的领域，建立好自己的优势，制造出差异性。如果你对自己的领域不够清晰的话，随着你工作的时间日益增多，你接触的技术会越来越多，这个时候，你很容易被淹死在技术的海洋里，看似接触的技术越来越多，会用的也越来越多，但你毫无优势。有的同学可能会问，“我，我也不知道我的领域是什么啊？怎么办呢？”对于这种人，我只想说，“卧槽，这还问我？要不干脆我替你学习得了，好不好？”\nstep 5 参加工作4年到5年的同学\n对于参加工作4年到5年的同学，经过前面一年的历练，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去GitHub创建一个属于你的开源项目，去打造自己的产品。\n这次的开源项目不同于之前的造轮子，你这个时候是真的要去尽量尝试造出来真正对别人有价值的轮子。技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。程序猿在某种程度上和明星很像，一个好的电视剧和电影就可以成就一批明星，程序猿有的时候也是，一个好的项目就可以成就一群程序猿。比如国内几个脍炙人口的项目，像淘宝、支付宝、QQ、百度、微信等等。这每一个项目，都成就了一批程序猿。我敢说，这里面任何一个项目，如果你是它的核心开发，光是这样一个Title，就已经是你非常大的优势。更何况还不止如此，Title说到底也是个名头，更重要的是，这种项目在做的时候，对你的历练一定也是非常给力的。\n而你如果想要参与这样的项目，除了靠运气之外，影响力也是很重要的一个手段。比如你在分布式计算领域有一定的影响力，那么如果有什么好的关于分布式计算的项目，对方就很可能会邀请你。就算人家不邀请你，你自己主动去面试的时候，对方如果知道你在这个领域的影响力，也肯定会起到很大的作用，而这个作用，甚至可能会超过你现在的技术能力。所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。如果你能够靠你的影响力和以前积累的技术，参与到一个伟大的项目当中，那么你后面的五年也就有着落了。当然了，我现在满打满算，做程序猿也就4年半不到，因此关于4年到5年这一部分，我的见解不一定是对的，就算是对的，也不一定是适合任何人的。\n所以，希望大家自己有的判断力，去决定到底该如何度过这一年。\n结语\n本文到此就基本结束了，整篇文章很长，但其实主要就说了两部分内容，一个是社招面试的准备，一个是Java生涯的学习。关于这两部分，我已经给出了自己的见解，但是还是那句话，每个人吸收知识的时候，都要有抽取精华，去除糟粕的能力。我所说的，可能有些是对的，有些是错的，有些是适合你的，有些是不太适合你的，你要自己能够判断。其实你在生活和工作当中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你很讨厌。但其实你喜欢的人也有缺点，你讨厌的人也有优点。你要学会从你讨厌的人身上学会他的优点，千万不要一棒子打死，这只会让你失去很多学习成长的机会。好了，说了这么多了，就到此为止吧，希望本文可以帮助到作为程序猿或即将成为程序猿的你。\n声明：本文转载自网络，原文地址。\n这篇文章发表自2016年，距离现在已经过了很长一段时间。可能再过一段时间，会出现更多的技术，学习路线可能也会发生改变。但是这篇文章的一些想法和思路是非常值得借鉴和学习的。—2018年6月17日\n整理博客时，又看到了这篇文章。这回正式决心杀进程序猿行业，拿出半年时间培训，最后一次机会，来之不易，成本颇大，规划好学习路线，必须比其他人掌握的更多，才能多一份机会。我发现培训机构的同学是真心都学习啊，课堂气氛太活跃了。—2020年4月20日\n","plink":"https://www.shiguangping.com/2018/06/java-learning-method/"},{"title":"Linux的几个有趣命令","date":"2018-06-14T14:53:09.000Z","date_formatted":{"ll":"2018年6月14日","L":"2018/06/14","MM-DD":"06-14"},"updated":"2020-09-19T16:09:59.717Z","content":"sl命令\n你会看到一辆小货车从屏幕右边开到了左边～\n12安装：sudo apt-get install sl运行：sl\nfortune命令\n输出一句话，有笑话、名言、唐诗宋词等等：\n12安装：sudo apt-get install fortune运行：fortune\ncowsay命令\n用ASCII字符打印牛、羊等动物。还有cowthink命令，这是是奶牛想，命令：\n12345安装：sudo apt-get install cowsay运行：cowsay -f tux &quot;坑爹啊～&quot;cowsay -l    查看其他动物的名字cowsay -f 动物们 &quot;坑爹啊～&quot;    可其他动物\ncmatrix命令\n这个是《黑客帝国》里面的代码雨，很cool：\n12安装：sudo apt-get install cmatrix运行：cmatrix\n使用Ctrl+C程序结束。\nfiglet、toilet命令\n艺术字生成器，由ASCII字符组成，把文本显示成标题栏。此外还有banner这个命令：\n1234安装：sudo apt-get install figlet    sudo apt-get install toilet运行：figlet I LOVE YOU !    toilet I LOVE YOU !\n此外toilet还可以添加颜色\n1toilet -f mono -F gay I LOVE YOU !\noneko命令\n这个也比较有趣，桌面上出现一只喵星人，会跟着你的鼠标再跑，Ctrl+C结束：\n12安装：sudo apt-get install oneko运行：oneko\nyes命令\n一直输出字符，使用Ctrl+C结束：\n1yes I LOVE YOU !\ncal命令\n这个是打印日历：\n1cal 6 2018\n结尾\n这些命令是在今日头条看到的，很有趣。\n","plink":"https://www.shiguangping.com/2018/06/linux-funny-commond/"},{"title":"在Linux中使配置alias永久生效","date":"2018-06-13T15:06:45.000Z","date_formatted":{"ll":"2018年6月13日","L":"2018/06/13","MM-DD":"06-13"},"updated":"2020-09-19T16:11:30.344Z","content":"编辑.bashrc\n在终端，通过命令回家：\n1cd ~\n之后通过文本编辑器编辑文本.bashrc：\n1sudo gedit .bashrc\n或者，使用vim编辑：\n1sudo vim .bashrc\n如果没有.bashrc文件，需要手动创建一个。\n注意：.bashrc是隐藏文件，在文件管理器中查看时需要勾选显示隐藏文件。\n创建好之后，在.bashrc最后一行添加你要设置的alias命令，例如：\n1alias hxc=&#x27;rm -f ~/blog/db.json &amp;&amp; hexo clean&#x27;\n如果是新建的.bashrc文件，直接在里面添加alias命令就可以，命令是一行一行的。\n添加完之后保存，再通过source命令使刚才的配置文件生效：\n1source .bashrc\n之后在终端敲击alias命令，查看刚刚配置的alias命令是否生效。\n编辑.bash_profile\n在.bash_profile最后一行添加一条命令：\n1source ~/.bash_profile\n注意：如果没有.bash_profile文件就新建一个。\n添加完之后保存退出，终端通过source命令使配置生效：\n1source .bash_profile\n此时可以重新打开终端，输入alias命令，查看配置的alias是否已经生效。\n","plink":"https://www.shiguangping.com/2018/06/alise-linux/"},{"title":"Hexo上传本地源文件到GitHub","date":"2018-06-13T01:34:21.000Z","date_formatted":{"ll":"2018年6月13日","L":"2018/06/13","MM-DD":"06-13"},"updated":"2020-09-19T13:22:14.043Z","content":"前言(可忽略不看)\n这个问题是在我部署完HEXO博客之后就想到的，我要是换了一台电脑或者重新装系统之后，还怎么更新HEXO博客呢？\n我今天在网上开始寻找解决办法，上网一看才知道这是很多人很早以前就面临的问题，当然有很多大神做了解答，但是绝大多数的回答我都是看不懂的。大多数的办法是在同一个GitHub仓库创建两个分支，一个用来存放HEXO上传的静态页面，一个用来保存HEXO的本地源文件。但是对于我这个小白来说，仓库一词我都是最近才知道的，更别提分支了。还有一大堆的命令，我也看不懂所以然。\n最后，我还是用了这个办法，在原有的仓库基础上再创建一个分支，用来保存本地的源文件。（网上主要的还是这个办法）\n我试着把我的操作流程写下来，可能其中会有遗漏或者小错误，遇到问题只能自己解决了。因为我也是凭借自己理解操作的。\n我为什么要把源文件上传到GitHub呢？\n因为我今天在电脑上安装了Linux，所以以后敲字都要靠Linux了。\n一.本地源文件上传到GitHub：\n1.提前准备\n首先，不论是在另一台电脑上还是重新安装了系统，都要安装好Node.js和Git，还有HEXO，它们的安装方式具体参考HEXO的说明文档。\n2.操作流程\n1.登录到GitHub，打开hexo所在的仓库，在博客所在的repository新建一个分支hexo，在仓库Setting下的Branches中，设置hexo为默认分支。\n2.克隆repository到本地，命令如下：\n1git@github.com:ENNRIaaa/shiguangping-blog.git\n注：克隆的文件夹保存在哪取决于你所在的位置，可通过pwd命令查看你当前所在位置。\n3.克隆好之后，打开本地的文件夹，默认的文件夹名字就是repository的名字，把文件夹内除了**.git文件夹之外的所有文件全部删除。注意：.git是隐藏文件夹。\n4.之后把原电脑上的HEXO文件全部复制到这个文件夹下。\n5.复制完之后里面应该有一个名为.gitignore**文件，如果没有的话通过终端命令创建：\n1touch .gitignore\n正常**.gitignore**的内容是：\n\n\n.DS_Store\n\n\nThumbs.db\n\n\ndb.json\n\n\n*.log\n\n\nnode_modules/\n\n\npublic/\n\n\n.deploy*/\n\n\n6.切换到hexo分支上，命令如下：\n1git checkout -b hexo\n7.提交复制过来的文件到暂存区，命令如下：\n1git add --all\n8.提交，命令如下：\n1git commit -m &quot;新建分支资源文件&quot;\n引号内的内容自定义，就是一个备注。\n9.推送分支到GitHub上，命令如下：\n1git push origin hexo\n推送成功之后，到GitHub仓库刷新一下，看看hexo分支下是否已经成功上传了本地的源文件。\n到这里，本地的源文件已经上传到GitHub上，HEXO本地源文件直接使用git push命令就可以了，HEXO发博客的操作跟以前一样，还是这三步：hexo c、hexo g、hexo d -g。\n注：期间终端可能会提示需要输入一下密码啊，或者提示让你输入邮箱和用户名等，只需根据提示输入即可。\n在安装完Git和node.js之后，我就把SSH密钥配置完了。设置GitHub的SSH密钥，可参考GitHub如何配置SSH。\n二.如果今后换电脑该如何操作\n本地源文件保存到GitHub之后，今后在其他电脑上或者重装系统后，先把Git、Node.js、HEXO这些基本的都安装好,（注意：Hexo安装好之后不要执行hexo init初始化命令），再把GitHub上保存HEXO源文件的hexo分支克隆到本地即可。\n克隆分支的命令：\n1git clone -b hexo git@github.com:ENNRIaaa/shiguangping-blog.git\n-b后面的是分支的名称，后面替换自己仓库的链接。\n结尾\n今天主要提供帮助的是CSDN博主LeonWuV,如果我的文章有一些地方看不懂，或者有错误，可参考此博主的文章。\n本文写了一个多小时，终于结束了。虽然很墨迹，但是很快乐。\n","plink":"https://www.shiguangping.com/2018/06/hexo-local-source/"},{"title":"GitHub如何配置SSH","date":"2018-06-12T16:16:26.000Z","date_formatted":{"ll":"2018年6月12日","L":"2018/06/12","MM-DD":"06-12"},"updated":"2020-09-19T13:18:14.850Z","content":"一、生成SSH Key\n在Git Bash终端输入命令：\n1ssh-keygen -t rsa -C &quot;china_liyan123@yahoo.co.jp&quot;\n此处邮箱替换为自己的邮箱地址。\n此时终端提示：\n\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/shado/.ssh/id_rsa):\n\n终端会让你选择存放SSH的路径，括号内的是默认路径。\n直接回车选择默认路径，终端提示输入SSH密码，需要输入两次，此时输入的密码不会显示在终端上，敲完接回车即可。\n\nYour identification has been saved in /c/Users/shado/.ssh/id_rsa.\nYour public key has been saved in /c/Users/shado/.ssh/id_rsa.pub.\n\n之后终端提示密钥已经生成，在刚才选择的默认路径中，其中id_rsa是私有密钥，id_rsa.pub是公共密钥。\n二、在GitHub中添加密钥\n登陆GitHub，在页面右上角头像选择下拉菜单中Setting，在设置页面SSH and GPG keys标签页，在这个标签页下添加SSH。\n点击页面右上角New SSH key按钮，添加SSH密钥。\n打开保存SSH的默认路径，打开id_rsa.pub（用任意文本编辑器打开即可），复制里面的内容，粘贴到New SSH key的key里面，Title自定义即可，之后点击Add。\n回到终端窗口，敲入命令：\n1ssh -T git@github.com\n此时终端提示：\n\nEnter passphrase for key ‘/c/Users/shado/.ssh/id_rsa’:\n\n输入之前设置的密码，输入时密码不会显示在终端上。\n密码输入正确后，终端会提示：\n\nHi ENNRIaaa! You’ve successfully authenticated, but GitHub does not provide shell access.\n\n说明SSH密钥已经配置成功。\n","plink":"https://www.shiguangping.com/2018/06/github-ssh/"},{"title":"小白部署HEXO到GitHub","date":"2018-06-10T02:38:31.000Z","date_formatted":{"ll":"2018年6月10日","L":"2018/06/10","MM-DD":"06-10"},"updated":"2020-09-19T13:22:41.345Z","content":"前言\n呃，终于忙乎完了!\n从昨天傍晚的7点半一直到现在的2点50分，并且到目前都还在折腾，这也是第一篇文章，即将要上传到GitHub上的。\n之前我是没有接触过GitHub和HEXO的，我现在在用的博客程序是z-blog，它部署在腾讯云，地址是：时光瓶,现在之所以搞hexo，是因为看到了一位前端大咖的博客，diygod.me，看到之后很惊艳，由此认识到了hexo和GitHub。\n通过维护这个博客开始我的学习之旅，慢慢了解GitHub，了解开源世界。\n然后说一下现在正在用的这个HEXO主题，这个主题是像素风格的，很有魔性，所以就采用了。在此感谢主题的作者，作者的博客有关于这个主题的说明，虽然我看作者已经很久没有更新他的博客了，主题作者.\n开始搭建\n1. 本地安装HEXO\n安装步骤可以参考官方文档，中文地址。\n安装前提\n\n\nNode.js（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）\n\n\nGit\n这两个是安装Hexo之前必须要安装的\n\n\n安装Hexo\n1npm install -g hexo-cli\n安装完Hexo之后，执行下列命令，Hexo会在指定文件夹新建所需文件。\n123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install\n新建完成后，指定文件夹的目录如下：\n12345678.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n每个文件的作用请参考官方文档，文档包含详细的安装和配置步骤。\n1hexo server\n启动服务，默认情况下，使用浏览器访问地址://localhost:4000/，如果这个地址无效，可通过命令：\n1hexo server -p 5000\n-p 指定端口，重新尝试。如果可以正常访问，页面正常，说明本地配置OK。\n2. 下载和安装主题\n我使用的主题是blackshow编写的开源主题，该主题基于Freemind修改，样式替换为BOOTSTR.386.作者的博客里有提到。\n\n安装主题：\n\n1git clone git@github.com:blackshow/hexo-theme-freemind.386.git themes/freemind\n\n安装 hexo-tag-bootstrap （可选）:\n\n1npm install hexo-tag-bootstrap --save\n\n安装 hexo-generatr-search （可选）：\n\n1npm install hexo-generator-search --save\n\n创建页面：\nFreemind 预先定义了 Categories（分类）、Tags（标签） 和 About（关于）页面，要使用它们，你需要先在你的博客的 source 目录中添加相应页面。\n例如，要创建 Categories 页面，在终端上:\n\n12cd /path/to/hexo/hexo n page categories\n然后编辑 source/categories/ 下的 index.md，内容如下：\n12title: Categorieslayout: categories\n\n关于主题的配置和一些相关问题，具体请参考主题作者的说明文档和原作者关于Freemind的说明文档。\n每一步如果想预览，使用一下命令，通过浏览器预览访问本地预览：\n\n1hexo server\n3. 把本地Hexo部署到GitHub\n\n注册GitHub帐号，然后登陆。\n在GitHub新建一个repository，页面的右上角有个加号，里面的New repository\n这里的Repository Name要和前面的Owner名字相同，格式就是这样的ENNRIaaa.github.io，ENNRIaaa就是我的Owner名字，然后选择public，创建就可以了。\n编辑HEXO目录下的站点配置文件_config.yml，在最下面加上几行\n\n1234deploy:      type: git      repository: https:&#x2F;&#x2F;github.com&#x2F;ENNRIaaa&#x2F;ENNRIaaa.github.io.git      branch: master\n把地址替换为自己GitHub库的地址\n然后在终端一次敲如命令：\n123hexo clean //清除public文件hexo g //生成静态文件hexo d -g //把html静态文件推送到GitHub\n此时可能会提示输入GitHub的用户名和密码。我看网上有教程说此步骤需要配置SSH，这个由于我没有配置，也不太懂，所以不多说明。（后续会写如何配置SSH）\n本地文件上传到GitHub之后，访问刚才的ENNRIaaa.github.io，看看是否能正常访问到你的博客。\n4. 绑定个人域名\n如果你不需要绑定个人域名，可以忽略这一步，博客可直接通过ENNRIaaa.github.io访问。\n\n在你域名的解析页面添加解析，我是添加的CNAME，直接解析ENNRIaaa.github.io，有的人添加的A记录解析的博客的IP地址。\n在刚刚创建的GitHub的repository，选择Setting标签页，在下面的GitHub Pages里面有Custom domain，填上你的域名，Save就可以了。如果没有Custom domain，那就把GitHub Pages下的Source改为master branch。\n在访问绑定的域名，看看是否能正常访问到博客。\n\n关于新建文章\n新建文章需要使用markdown文档编辑工具，我使用的是Typora，支持win/mac平台，编辑时所见即所得。\n文章的头部通过这几个标签来定义标题，日期，描述，分类，标签等…（具体只能靠自己摸索）\n1234567title: 小白部署HEXO到GitHubdate: 2018-06-10 02:38:31description: 从傍晚到凌晨，HEXO和GitHub摸索中categories: 生活随笔tags: [hexo,GitHub]toc: truefeature:\n总结\n我从昨晚一直折腾到今天早晨，很累。\n本文搭建流程都靠记忆，因为之前没有接触过这些，我也不是编程工作者，所以很多都是通过google一点一点地查，遇到问题的时候，网上给出的答案也是很零散的。\n我写的这个流程可能也有一些错误或者失误的地方，遇到问题只能自己摸索了。\n\n关于命令以及配置文件.yml对格式的要求很严谨，例如:\n\n1type: git\n冒号：和后面的git之间都要有空格。\n\n每次写完文章，上传到GitHub之前都要：\n\n123hexo c --删除public文件夹hexo g --生成静态文件hexo d -g --上传到GitHub仓库\n\n关于上面三个命令可参照主题作者的HEXO使用心得这篇文章。\n\n关于搭建和使用hexo，可以看看主题作者的博客，他有几遍文章专门是介绍说明HEXO的使用的，很有帮助。\n\n每次上传到GitHub之后，访问绑定的域名可能会遇到404页面，解决办法是到repository的Setting–&gt;GitHub Pages重新设置域名，再到本地hexo目录下的source，添加一个名为CNAME的文件，文件内容是自己绑定的域名，问题解决。不会新建文件的可通过新建文本文档命名为CNAME，然后编辑内容，之后保存，再删除掉该文档的后缀即可，即删除.txt。\n\n\n本文到此结束。\n","plink":"https://www.shiguangping.com/2018/06/build-hexo/"},{"title":"解决Linux中eclipse导入Windows项目后出现中文乱码问题","date":"2018-05-16T00:00:00.000Z","date_formatted":{"ll":"2018年5月16日","L":"2018/05/16","MM-DD":"05-16"},"updated":"2020-09-19T13:17:56.063Z","content":"我今天遇到这个问题，在百度问了一遍，大多数的方法都不行\n最后一个人给出的方法解决了这个问题\n\n我在linux下的eclipse导入windows的工程文件后，会出现这样的乱码问题。\n网上说，windows的中文编码方式是GBK，而linux采用的中文编码方式是UTF-8\n所以把linux的编码方式改一下就可以了。\n在出现乱码的文件，键盘敲入 alt+Enter，会出现一个对话框\n\n在下面的Text file encoding，Other里面直接输入GBK，然后应用，这时正常的中文就回来了。\n\n感谢这个大神\n","plink":"https://www.shiguangping.com/2018/05/eclipse-text-encoding/"},{"title":"Linux学习之~ubuntu安装jdk及配置环境变量","date":"2018-05-15T00:00:00.000Z","date_formatted":{"ll":"2018年5月15日","L":"2018/05/15","MM-DD":"05-15"},"updated":"2020-09-19T13:06:50.893Z","content":"1. 下载jdk\n前往jdk官网下载jdk，地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html\n\n现在已经更新到jdk10了，但是我下载解压之后发现里面没有jre文件夹，不知为何。为了不发生同样的问题，推荐下载之前的版本。\n（文章具有一定的时效性，不代表之后也会出现同样问题）\n\n我下载的是linux x64的版本，jdk-8u172-linux-x64.tar.gz\nubuntu系统的话，默认会下载到“下载”里面（我用的ubuntu版本是18.04LTS）\n2. 创建文件夹，将jdk解压到该文件夹内\n\n进到/usr/lib/文件夹下，\n\n1cd /usr/lib\n\n在当前文件夹输入sudo mkdir jvm创建文件夹\n1sudo mkdir jvm\n此时可以用命令查看文件夹是否创建成功\n1ls -l\n看看是否有jvm这个文件夹。\n\n\n然后利用cd命令回到“下载”文件夹，把下载好的jdk移动到刚刚创建的jvm文件夹\n\n1sudo mv jdk-8u172-linux-x64.tar.gz /usr/lib/jvm\n然后进入/usr/lib/jvm文件夹，查看该文件是否存在\n\n用tar -zxvf命令解压\n\n1sudo tar -zxvf jdk-8u172-linux-x64.tar.gz\n解压完成后可以用ls -l命令查看是否解压成功\n（注：在2步骤时，可以在下载文件夹直接将下载好的jdk解压到目标目录/usr/lib/jvm里，然后在回到jvm目录查看是否解压成功）\n也可以直接通过命令解压到指定文件夹：\n1sudo tar -zxvf jdk-8u172-linux-x64.tar.gz -C /usr/lib/jvm\n3. 配置环境变量\n编辑.bashrc文件\n1sudo gedit ~/.bashrc\n\n在结尾fi后面加上这四段代码：\n1234export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_171export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n第一行JAVA_HOME是jdk的安装路径，这里一定不要写错。\n编辑保存之后，在终端输入：\n1source ~/.bashrc\n使.bashrc生效，如果提示权限问题，在命令前面加上sudo\n4. 安装完成，验证java是否配置完成\n在终端输入：\n1java -version\n\n终端出现java的版本号信息，说明jdk环境变量配置成功。\n","plink":"https://www.shiguangping.com/2018/05/ubuntu-java-path/"},{"title":"JDK安装及配置环境变量","date":"2018-04-13T21:51:00.000Z","date_formatted":{"ll":"2018年4月13日","L":"2018/04/13","MM-DD":"04-13"},"updated":"2020-09-19T16:08:12.730Z","content":"Java开发需要安装JDK（Java开发工具），JDK里面包括Java编译器，和JRE（Java运行时环境），其中JRE里面又包含JVM（Java虚拟机）、Java核心类库以及相关支持文件。\n所以，在开发Java程序之前，必须先安装JDK。（只为了运行Java程序，只需安装JRE即可）\n1. 下载JDK及安装\n访问Oracle官方下载地址下载所需的JDK版本。\n下载好的安装包是.exe可执行文件，直接双击下一步即可，安装路径推荐默认。\n\n2. 配置环境变量\nJDK安装完成之后，就需要给系统配置Java环境变量了。\n\n配置环境变量是在：桌面计算机右键属性–&gt;高级系统设置–&gt;环境变量\n编辑上图中系统变量中的Path，把JDK的路径地址加入到Path中。\n(配置环境变量目的是让操作系统知道JDK)\nJDK的默认安装路径一般在C盘下Program Files --&gt;Java文件夹下，参考下图。\n（路径一定要全，复制到jdk文件夹下的bin文件夹）\n\n把这个路径粘贴到系统变量的Path中，每个路径之间用“ ; ”隔开，注意：分号是英文输入状态下的.\n编辑确定之后，在cmd窗口敲入命令：\n1java -version\n\n终端提示Java版本号，说明环境变量配置成功。\n也可以在cmd里敲javac或java，这时说明java环境变量已经配置成功了。\n如果没有配置成功，终端会显示【不是内部或外部命令，也不是可运行的程序或批处理文件】。\n","plink":"https://www.shiguangping.com/2018/04/java-build-path/"},{"title":"","date":"2020-09-19T21:06:50.894Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-09-19T13:06:50.894Z","content":"关于我\n李炎，94年生，在大连从事了多年移动网络优化工作。\n目前正在学习Java开发。\n附上一张照片。\n  \n“灵明无著，物来顺应，未来不迎，当时不杂，既过不恋，是之谓虚而已矣，是之谓诚而已矣。” --曾国藩\n&quot;There is nothing noble in being superior to your fellow man; true nobility is being superior to your former self.&quot; – Ernest Hemingway\n“没有什么是比超越昨天的自己更有成就感的事儿了。” --2020年6月26日\n","plink":"https://www.shiguangping.com/about/"},{"title":"","date":"2020-09-19T21:06:50.894Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-09-19T13:06:50.894Z","content":"博文的自愿付费方式\n如果这里的内容对你有帮助，可以为我打赏支持。\n微信\n\n赞赏码\n\n支付宝\n\n","plink":"https://www.shiguangping.com/pay/"}]