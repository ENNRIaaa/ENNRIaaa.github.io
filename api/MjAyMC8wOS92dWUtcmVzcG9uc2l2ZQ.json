{"title":"Vue数据变化检测（无法检测对象/数组元素的变化问题）","date":"2020-09-24T10:21:00.000Z","date_formatted":{"ll":"2020年9月24日","L":"2020/09/24","MM-DD":"09-24"},"link":"2020/09/vue-responsive","tags":["Vue"],"categories":["Vue"],"updated":"2020-09-26T04:01:00.494Z","content":"<p>写代码时遇到这样一个问题，页面打开后进行axios请求数据，将响应回的数据赋值给data()中的一个对象，然后再v-for遍历对象将属性显示到页面中。</p>\n<p>但每次打开页面后要遍历显示的数据都没有显示出来，重新刷新或者点下其它的下拉框，要遍历的元素才显示。</p>\n<p>起初我以为是异步请求的问题，怀疑是先渲染DOM后请求的数据，后来查阅官方文档，原因是Vue无法检测对象和数组的变化。</p>\n<a id=\"more\"></a>\n<h1 id=\"深入响应式原理\">深入响应式原理<a title=\"#深入响应式原理\" href=\"#深入响应式原理\"></a></h1>\n<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters\" target=\"_blank\">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>\n<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\">vue-devtools</a> 来获取对检查数据更加友好的用户界面。</p>\n<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>\n<p><img src=\"https://images.shiguangping.com/imgs/20200924102724.png\" alt=\"data\" class=\"φcx\"></p>\n<h2 id=\"检测变化的注意事项\">检测变化的注意事项<a title=\"#检测变化的注意事项\" href=\"#检测变化的注意事项\"></a></h2>\n<p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p>\n<h3 id=\"对于对象\">对于对象<a title=\"#对于对象\" href=\"#对于对象\"></a></h3>\n<p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data:&#123;</span><br><span class=\"line\">    a:<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// `vm.a` 是响应式的</span></span><br><span class=\"line\"></span><br><span class=\"line\">vm.b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure>\n<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。例如，对于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.set(vm.someObject, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$set(<span class=\"built_in\">this</span>.someObject,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>有时你可能需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.someObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"built_in\">this</span>.someObject, &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"对于数组\">对于数组<a title=\"#对于数组\" href=\"#对于数组\"></a></h3>\n<p>Vue 不能检测以下数组的变动：</p>\n<ol>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>\n</ol>\n<p>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    items: [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">vm.items[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;x&#x27;</span> <span class=\"comment\">// 不是响应性的</span></span><br><span class=\"line\">vm.items.length = <span class=\"number\">2</span> <span class=\"comment\">// 不是响应性的</span></span><br></pre></td></tr></table></figure>\n<p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Vue.set</span></span><br><span class=\"line\">Vue.set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Array.prototype.splice</span></span><br><span class=\"line\">vm.items.splice(indexOfItem, <span class=\"number\">1</span>, newValue)</span><br></pre></td></tr></table></figure>\n<p>你也可以使用 <a href=\"https://cn.vuejs.org/v2/api/#vm-set\" target=\"_blank\"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>\n<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明响应式-property\">声明响应式 property<a title=\"#声明响应式-property\" href=\"#声明响应式-property\"></a></h2>\n<p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明 message 为一个空值字符串</span></span><br><span class=\"line\">    message: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 之后设置 `message`</span></span><br><span class=\"line\">vm.message = <span class=\"string\">&#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>如果你未在 <code>data</code> 选项中声明 <code>message</code>，Vue 将警告你渲染函数正在试图访问不存在的 property。</p>\n<p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：<code>data</code> 对象就像组件状态的结构 (schema)。提前声明所有的响应式 property，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解。</p>\n<h2 id=\"异步更新队列\">异步更新队列<a title=\"#异步更新队列\" href=\"#异步更新队列\"></a></h2>\n<p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#example&#x27;</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">&#x27;123&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">vm.message = <span class=\"string\">&#x27;new message&#x27;</span> <span class=\"comment\">// 更改数据</span></span><br><span class=\"line\">vm.$el.textContent === <span class=\"string\">&#x27;new message&#x27;</span> <span class=\"comment\">// false</span></span><br><span class=\"line\">Vue.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  vm.$el.textContent === <span class=\"string\">&#x27;new message&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(<span class=\"string\">&#x27;example&#x27;</span>, &#123;</span><br><span class=\"line\">  template: <span class=\"string\">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      message: <span class=\"string\">&#x27;未更新&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateMessage: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.message = <span class=\"string\">&#x27;已更新&#x27;</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; &#x27;未更新&#x27;</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; &#x27;已更新&#x27;</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\">ES2017 async/await</a> 语法完成相同的事情：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  updateMessage: <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.message = <span class=\"string\">&#x27;已更新&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; &#x27;未更新&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.$nextTick()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.$el.textContent) <span class=\"comment\">// =&gt; &#x27;已更新&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>官方原文：<a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\" target=\"_blank\">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>\n<hr>\n<p>因为我请求的数据赋值给一个对象，Vue无法检测对象中的属性变化，所以可以使用<code>this.$set(object, propertyName, value)</code>这种形式将响应回的数据赋值给data()中的对象。</p>\n","prev":{"title":"还不懂Redis？看完这个故事就明白了！","link":"2020/09/redis-story"},"next":{"title":"Vue验证表单字段常用规则","link":"2020/09/vue-form-validator"},"plink":"https://www.shiguangping.com/2020/09/vue-responsive/","toc":[{"id":"深入响应式原理","title":"深入响应式原理","index":"1","children":[{"id":"检测变化的注意事项","title":"检测变化的注意事项","index":"1.1","children":[{"id":"对于对象","title":"对于对象","index":"1.1.1"},{"id":"对于数组","title":"对于数组","index":"1.1.2"}]},{"id":"声明响应式-property","title":"声明响应式 property","index":"1.2"},{"id":"异步更新队列","title":"异步更新队列","index":"1.3"}]}]}