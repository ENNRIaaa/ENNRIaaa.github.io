<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>比特宇宙－TCP/IP的诞生</title>
      <link href="/2020/09/tcpip-birth-talk-talk/"/>
      <url>/2020/09/tcpip-birth-talk-talk/</url>
      <content type="html"><![CDATA[<p>比特宇宙创世不久，宇宙中开始出现文明。</p><p>文明不断碰撞、融合、进化，逐渐分化为几大派系：</p><p>施行Unix体制的帝国，出现时间最早，在宇宙中最有威望。</p><p>施行Windows体制的帝国，数以十亿计，成为宇宙中最庞大的军团。</p><p>施行Linux体制的帝国，后起之秀，曾和Windows帝国军团爆发多次战争，后握手言和，割据一方。</p><p>随着文明的发展，宇宙之间的各帝国逐渐意识到需要发展经贸合作，互通有无。终于有一天，几大派系的帝国派了代表聚在一起，商讨比特宇宙的经贸合作框架协议。</p><p><strong>☆ 第一天 ☆</strong></p><p>会议第一天的议题，商讨经贸合作的最重要的基础：制定比特宇宙通信标准。</p><p>Unix代表首先发言：我们需要制定一套普世的宇宙标准，让全宇宙的帝国都能互相通信，大家有什么想法，请畅所欲言。</p><p>Linux：最简单有效的办法，帝国之间都建一条专有线路，就像这样，构成一张巨大的网络，我们就能和任何帝国通信了。</p><img src="https://images.shiguangping.com/imgs/20200928132850.png" alt="img" style="zoom:50%;" /><p>Windows：你想的也太简单了，你知道咱们Windows星系有多少帝国吗？建专有线路，这得花多少钱？就算你有钱，帝国要建这么多线路，那也不堪重负。<br>Linux：别着急，我还有办法。咱们找一个帝国作为网络中心节点，专门负责数据转发，其他帝国只需和中心建一条专线就可以，这一下能省很多线路的钱。诺，就像这样：</p><img src="https://images.shiguangping.com/imgs/20200928132858.png" alt="img" style="zoom:50%;" /><p>Windows：确实省了不少，但你有没有想过，这个中心节点得多么重要，工作负担巨大倒是其次，一旦中心帝国覆灭，全宇宙的通信全部中断，这是多么严重的后果？Linux皱了眉头，不再说话。</p><p>Unix：其实这个方法挺不错的，不过需要一点改进会更好。就像你说的，一个中心节点不够，咱们可以弄多个啊，然后这多个中心节点之间再互相连接，把一个中心变成多个中心。嗯，其实这里就不再存在中心了，就是一个去中心的分布式网络了，你们觉得怎么样？</p><img src="https://images.shiguangping.com/imgs/20200928132907.png" alt="img" style="zoom:50%;" /><p>Linux：唉，这个好！我还想到了一招，既然咱们宇宙中帝国众多，就把你说的中间这些节点再进一步划分层级，也就是划分为一个个子网络，然后子网之间连接组成大的网络，然后大的网络之间再连接构成更大的网络！我是不是个天才！</p><img src="https://images.shiguangping.com/imgs/20200928132915.png" alt="img" style="zoom:50%;" /><p>Windows：嗯，听起来挺不错的，不过有一个问题还没解决，就是非常遥远的两个帝国之间要通信，网络通道该怎么建立呢？中间节点要如何给这两个帝国搭建出一条专线，让他们通信呢？</p><p>·······一阵沉默·····</p><p>·Unix：为什么非得建立专线呢？这样效率太低了，如果一条线路给你们占用了，别人要经过这条线的是不是得一直等着？</p><p>Linux：说的有道理，那你有什么好主意？</p><p>Unix：我们可以把数据拆分为一个个的单元，分组传输，每个单元写好发件人、收件人，中间的节点负责存储转发就可以了嘛，这样大家都可以用这个网络，效率大大提升。</p><p>Windows代表拍案而起，“这简直是划时代的想法！大佬果然是大佬！”</p><p>Linux：非常棒的想法，我们给这种技术取个名字吧，既然是分组，然后存储转发，要不然叫”分组交换技术“怎么样？</p><p>Unix：嗯，这名字很贴切，就叫它！</p><p>Linux：我们给这个巨大的网络也取一个名字吧，叫Internet怎么样？</p><p>Unix：Internet，因特网，听起来还不错</p><img src="https://images.shiguangping.com/imgs/20200928132927.png" alt="img" style="zoom:50%;" /><p>Windows：大佬，既然要通信，接下来咱们需要要讨论下通信协议了吧。</p><p>Unix：通信协议？</p><p>Windows：对啊，咱们得制定一套规范标准，所有帝国按照这套规范来收发信息，才能互相理解对方在说什么。</p><p>Unix：嗯，确实需要这么一套标准协议。既然网络叫Internet，那咱这套标准协议就叫Internet Protocol，那具体协议内容怎么制定呢？</p><p>Linux：等下，给我个表现机会，让我先说说。</p><p>Windows：洗耳恭听。</p><p>Linux：咱们给所有帝国编一个号，用4个字节的整数来表示，嗯，我想想，从0x00000000到0xFFFFFFFF，差不多能表示42亿多个帝国了，绰绰有余了。这个编号，就叫Internet Protocol Address，也就是IP地址。</p><p>Windows：嗯，用是够用了，不过我建议不要用16进制表示，不太好书写，人类那智商肯定记不住。既然是4个字节整数，要不就用人类熟悉的4个十进制整数来写，用点来隔开，像这样：0.0.0.0～255.255.255.255，把这种写法叫做IP地址的点分十进制表示法，怎么样？**<br>**</p><p>Linux：嗯，这个建议好，可以采纳。我刚才还没讲完，通信的时候，数据前面加一个头部，头部里面写上发件人的IP地址、收件人的IP地址，这样发送出去，然后交给网络中的中间节点，让他们转发出去…</p><p>Windows：等一下，有一个问题，中间节点该如何知道转发给谁呢？·······又是一阵沉默······</p><p>Linux：有了，人类收发快递的时候，他们的地址是分了省，市，县到街道，一层层分级了，逐级进入就能找到收件人的地方。咱们的网络也可以这样效仿，把网络分不同大区，大区里面分子网。然后负责转发的这些中间节点，记录一张表，表里面记录不同地区的地址该交给谁，如此，不同层级负责不同的地区，整个网络就能运转起来，收发信息了。</p><p>Unix：这个办法好，咱就把这种技术叫路由技术，这个表叫做路由表。</p><p>Windows：确实很有头脑嘛，不过我想到有一种情况可能可能比较难办。</p><p>Linux：什么情况，别卖关子了。<br>Windows：如果写了一个不存在的收件人，或者是中间节点的路由表里面都没有记录这个帝国，甚至有些中间节点之间踢皮球，谁都不知道交给谁，互相推诿，那发出去的数据包裹岂不是要在网络里面转圈圈，没完没了浪费资源了？<br>Linux：额，好像确实是有这么个麻烦问题，你解决问题没啥能力，挑刺倒是一把好手嘛！</p><p>Unix：有了！咱们在在这个头部里面除了写上收发地址外，再加一个计数器，表示这个包裹的生命周期，发件人初始设置一个数字，表示允许最多在网络中传递几次。中间节点收到后，就把数字减1，如果某个节点拿到后发现减1后变成0，那就丢掉它不再传输了</p><p>Linux：嗯，这个办法好，这个计数器也取一个名字，叫Time to Live吧，就是生存时间的意思，简写成<strong>TTL</strong>。</p><p>Windows：大佬，果然有经验，佩服佩服。不过原谅我还要继续提问题哦。</p><p>Linux：你的问题怎么这么多，快说！<br>Windows：帝国之内有许多的公司都需要经贸合作，如何能进一步区分是哪家公司的信息呢？</p><p>Linux：这样看来，4个字节整数不够用啊，再加一点怎么样，给每个公司都弄一个编号。</p><p>Windows：这恐怕不太现实，帝国的公司经常在变化，每天诞生消亡不计其数，还有些公司根本不做国际化贸易，不需要网络通信，这种办法不好操作。</p><p>Linux：这，，，</p><p>Unix：今天时间也不早了，要不明天继续讨论这个议题如何，今天的收获已经不少了。</p><p>Linux：好的，我回去再琢磨琢磨。</p><p><strong>☆ 第二天 ☆</strong></p><p>Unix：两位昨晚休息的如何？</p><p>Windows：还不错。</p><p>Linux：还行吧，对了，昨天最后那个问题我有新的解决方案了。</p><p>Windows：哦，是吗，我也想到了一个办法，要不你先说。</p><p>Linux：昨天的IP地址技术方案还是不变，IP地址只用来在网络中标识一个帝国，至于帝国内部的公司，由帝国内部自己管理。帝国内部再给自己的公司编个码，既然你说到公司会不断消亡和诞生，那这个号码就动态生成。</p><p>Windows：跟我想的差不多，帝国负责网络通信的部门给需要通信的公司分配一个号码，我取名叫端口号，用2个字节来表示，总共65535个端口号，公司要通信的时候，向帝国网络通信部门申请，用完就回收。通信过程中，把这个端口号也带上，帝国网络通信部门收到来自网络的信息包裹后，根据上面收件人的端口号，就能交给具体业务的公司了！<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><img src="https://images.shiguangping.com/imgs/20200928132935.png" alt="img" style="zoom:50%;" /><p>Linux：对对对，跟我想的简直一摸一样！</p><p>Unix：嗯，不错不错，其实我也想到了这个办法。好了现在怎么通信的问题解决了，大家觉得我们的标准还差什么不？</p><p>Linux：我觉得整体框架已经很完善了，有一个可以再优化一点的地方。</p><p>Unix：额哦，是什么呢？</p><p>Linux：目前的方案通信是没有问题了，但因为咱们的包裹都是拆开了一个个发，由于中间网络的路况变化，可能后发的先到，有些还可能丢掉了，需要补发，还有可能发重复了，还有可能后面发的优先级更高，需要加快处理等等各种复杂的情况其实还挺多的，咱们可能还得想一套办法来解决这个问题。</p><img src="https://images.shiguangping.com/imgs/20200928132944.png" alt="img" style="zoom: 67%;" /><p>Unix：呀，听你这么一说，我瞬间觉得问题还挺大的啊</p><p>Windows：看来简单的分组转发还不行，得有一套传输控制协议，来专门来解决上面的问题。</p><p>Linux：是的，你继续说下去。</p><p>Windows：我们来改造下原来的IP协议，除了把刚才说到的端口号也加进去，同时再设置一些标记，对包裹编号，这样收到后才好排序，去重。</p><p>Linux：嗯，想法不错，不过我不建议改造原来的IP协议，IP协议只负责帝国之间的传送，负责网络路由送达，至于数据的问题，不应该他来负责。我建议在IP协议后面再扩展一层出来，单独来做传输控制。</p><p>Unix：嗯， 我同意，不要把所有事情都搅合在一起，分层处理，每层只负责自己的职责。</p><p>Windows：也好，我也同意。</p><p>Linux：不过如何知道包裹丢失呢？</p><p>Windows：要不然这样，收到包裹后，得给一个答复，告诉发件人我收到了。</p><p>Linux：那其他问题呢？</p><p>Windows：额，暂时还没想好。</p><p>Unix：让我也出出注意，我们给这些数据包裹再加一些标志字段，用来对数据包裹进行编号，发送速度调节，优先级标识等等。</p><p>Windows：看起来可行，不过这双方可能在传输数据之前得先做些初始化工作。</p><p>Linux：嗯，要不在通信之前，双方先建立一个连接Unix：连接，怎么又要建立连接，不是分组转发吗？</p><p>Windows：是啊，你要开倒车吗？</p><p>Linux：两位先别急，此连接非彼连接，这是一个逻辑上的虚拟连接。正式通信之前先确认网络通达性，彼此做好初始化操作，可以理解为通过网络远程握手。通信完成后，再断开连接。</p><img src="https://images.shiguangping.com/imgs/20200928133000.png" alt="img" style="zoom:50%;" /><p>​</p><img src="https://images.shiguangping.com/imgs/20200928133008.png" alt="img" style="zoom:50%;" /><p>Windows：这样啊，倒是一个好办法。不过感觉这一套工作下来挺复杂的，有些公司业务比较简单，数据量小，信息包裹丢失大不了一会儿重发，弄这些感觉成本高，不一定所有公司会买账。</p><p>Unix：你说的这种情况也确实存在，要不这些比较简单的业务就不要走这套流程了，不用这套控制传输协议，单独弄一个简单版本的。</p><p>Linux：老大说的在理，刚才这套复杂的协议咱们取名叫TCP协议，就是传输控制协议的意思，老大说的简单版本的要不叫UDP，用户数据报协议，只记录收发公司的端口号就行，非常简单。</p><p>Unix：非常好，就这么愉快的决定了！<br>Linux：老大，咱们这套标准改个名吧，叫TCP/IP协议如何？</p><p>Windows：这是两个协议，加上其他协议，这是一个家族了，应该叫TCP/IP协议族。</p><p>Unix：同意！应该叫协议族才对！</p><img src="https://images.shiguangping.com/imgs/20200928133032.png" alt="img" style="zoom:67%;" /><p>第三天，Unix、Linux、Windows三大帝国集团代表发布《关于比特宇宙推进经贸合作的联合声明》，比特宇宙迎来全新的历史时期！</p><p>会议达成的网络通信标准TCP/IP协议族很快在比特宇宙中流行开来，无数的帝国纷纷拥抱因特网，没过多久，各种各样的网络业务便发展起来，因特网一片欣欣向荣。这其中发展最为迅速的要数Web业务，无数的帝国通过因特网相连，传输网页供人类浏览，后来人类又给他们取了一个新名字：互联网。</p><hr><p><strong>转载自<a href="https://www.cnblogs.com/xuanyuan/p/12009338.html" target="_blank">https://www.cnblogs.com/xuanyuan/p/12009338.html</a></strong></p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深夜，我偷听到程序员要对session下手……</title>
      <link href="/2020/09/session-cookie-jwt/"/>
      <url>/2020/09/session-cookie-jwt/</url>
      <content type="html"><![CDATA[<h2 id="我是一个web服务器">我是一个web服务器<a title="#我是一个web服务器" href="#我是一个web服务器"></a></h2><p>我是一个web服务器，我的工作是给人类提供上网服务，我每天要为数以万计的人提供网页浏览服务。</p><img src="https://images.shiguangping.com/imgs/20200926114956.image" alt="img" style="zoom:50%;" /><p>已经是深夜了，我还在和手下几个兄弟为了一件事紧张讨论着。</p><p>“老大，现在咱们每天处理的请求越来越多了，session同步的问题不能再拖了，必须想个办法”</p><p>“二哥说的是啊，老大，不能再拖了”</p><p>“老二，老三，咱们是一个集群，你们说的问题我不是不知道，我昨天听程序员们在讨论说要给我们接入一个叫<strong>Redis</strong>的家伙，相信这一问题很快就能得到解决啦，大家再忍忍。”</p><img src="https://images.shiguangping.com/imgs/20200926115009.image" alt="img" style="zoom:50%;" /><p>“Redis，他是谁，什么来头？怎么没听过这号人物”</p><p>“我也没见过，等等看吧”</p><h2 id="session-cookie时代">session-cookie时代<a title="#session-cookie时代" href="#session-cookie时代"></a></h2><p>到底是什么问题，让我们兄弟几个如此着急上火？事情还得从多年以前说起······</p><p>那时候，这俩兄弟还没来，就我一个web服务器，每天处理的不过是一些静态资源文件，像HTML、CSS、JS、图片等等，日子过的清闲自在。</p><img src="https://images.shiguangping.com/imgs/20200926115025.image" alt="img" style="zoom:50%;" /><p>日子一天天过着，互联网却悄然发生着变化。除了静态网页之外，可以动态交互的网络应用开始如雨后春笋般涌现，像各种各样的论坛啊，购物网站啊之类的。</p><p>这家公司的老板也不例外，招了一帮程序员要搞一套支持动态网页交互的网站出来。</p><p>以往的时候，我只需要按照HTTP协议的规范处理请求就完事儿了。不过动态交互应用出现后，我还得记住每一个请求背后的用户是谁，要不然就张冠李戴，全乱套了。</p><p>为了解决这个问题，程序员们想出了一个叫<strong>session</strong>的办法：</p><p>浏览器登陆以后，我就分配一个session id，表示一个会话，然后返回给浏览器，让它保存着。后续再来请求的时候，就把它给带上，我就能知道是谁啦！</p><img src="https://images.shiguangping.com/imgs/20200926115033.image" alt="img" style="zoom:50%;" /><p>还别说，这办法还是挺管用的，成功解决了用户身份识别的问题，这一用就是好几年。</p><p>不过，互联网的发展实在是太快了，用户量蹭蹭上涨，而我却发起了愁。</p><p>原先用户量少的时候，session id管理起来倒也简单，现在用户越来越多，对应的session id数量也与日俱增，我有点不堪重负了。</p><p>终于前不久，公司对web服务器进行了扩展，给我找来了两个小弟，还专门添置了一个nginx来进行负载均衡，这一下我们变成了3台web服务器组成的小集群了。</p><img src="https://images.shiguangping.com/imgs/20200926115041.image" alt="img" style="zoom:50%;" /><p>我的工作一下轻松了许多，两位小兄弟为了分担了不少。我原以为以后的日子要好过一些了，可没想到，两位小兄弟的加入却引入了新的问题。</p><p>原先的session id虽然很多，我一个人累是累点，但是方便管理啊！现在人手是增加了，可是这个session id的管理问题却变得复杂起来。</p><p>因为咱们现在是个集群，请求如果发到我这，我给登记了session id，但下一次请求说不定就发到老二那里，一会儿又发到老三那里，这个就说不准了，这样我们几个手头的信息不一致，就会出现一些异常情况，用户估计要破口大骂：这什么辣鸡网站？</p><p>后来我们跟nginx商量了一下，让他同一个用户来的请求都发给我们固定的一个人，这才稳住了局面。</p><p>不过好景不长，后面我们三兄弟都相继出现过宕机的情况，这时候nginx还是得把请求交给还在工作的兄弟，原来的问题就又出现了！</p><p>我们几个逼急了，商量了一下，干脆大家伙来同步session id的信息好了，有新增、失效的情况都给其他几个兄弟招呼一下，大家都管理一份，这样就不会出现不一致的问题了。</p><img src="https://images.shiguangping.com/imgs/20200926115049.image" alt="img" style="zoom:50%;" /><p>搞了半天，又变成以前一个人管理所有session id的情况了，不仅如此，还要抽出时间和几位兄弟同步，把session id搬来搬去，工作量不减反增了。</p><p>就这样艰难的过了一段日子，大家都怨声载道，所以有了开头的那一番讨论。</p><p>这一次，希望这位新来的叫Redis的伙伴能拯救我们。</p><h2 id="独立缓存——redis">独立缓存——Redis<a title="#独立缓存——redis" href="#独立缓存——redis"></a></h2><p>过了几天，总算把这个叫Redis的小伙伴给盼来了！</p><p>这小子看起来特别精神，了解清楚情况后，告诉我们说：“三位老哥，以后这session id都统一存在我这里吧，你们别各自保存了，这不是各位的擅长”</p><p>“你行吗？”，老二看着不太相信他的话，一脸不屑。</p><p>“行不行，试试不就知道了吗？”</p><img src="https://images.shiguangping.com/imgs/20200926115055.image" alt="img" style="zoom:50%;" /><p>接下来，我们听从了Redis的建议，不再保存这烦人的session id，全部一股脑儿交给了他，我们需要的时候再找他获取。</p><p>你还别说，这小子个子不大，本事不小，读写速度都特快，让我们头疼的问题总算是解决了！</p><h2 id="token时代">Token时代<a title="#token时代" href="#token时代"></a></h2><p>几个月后的一天···</p><p>“听说了吗？程序员们又要更改session id的存储方案了”，这一天，老二神神秘秘的说到。</p><p>“不对不对，我听到的版本是以后不用session id了，要变天了！”，老三也凑了上来。</p><p>一旁的redis老哥一听不乐意了，“咋的？是嫌我干的不好吗？”</p><p>我也赶紧催促，“你俩就别卖关子了，听到了什么，快说说”</p><img src="https://images.shiguangping.com/imgs/20200926115102.image" alt="img" style="zoom:50%;" /><p>老三示意大家围拢一些，小声说到：“我上次听两个程序员在议论，不知道他们在哪里学来了一套叫<strong>JWT（JSON Web Token）</strong> 的技术，硬说让我们来管理保存session id负担太重了，以后不保存了！还说，还说···”</p><p>“还说啥，你倒是说啊！”</p><p>“还说，Redis也不是万能的，也有崩溃的风险，一崩溃就全完了，所以要革新技术”，老三继续说到。</p><p>Redis一听更着急上火了，“我工作这么久以来，从没有撂过挑子吧，怎么能这么说我呢？再不行我也可以像你们搞个集群嘛”</p><p>“Redis老弟你先别急。唉，老三，这不保存session id，以后怎么鉴别用户呢？你有没有听到他们怎么说的？”</p><p>“听他们说，没有session id，但是换了一个<strong>token</strong>，用它来识别用户”</p><p>老二一听不以为意：“换了个名字，换汤不换药嘛！咱们还不是要保存token，才能匹配谁是谁”</p><p>老三摇了摇头：“不是的，这可不只是改了个名字那么简单！这个token是由三部分构成，就像这样：”</p><img src="https://images.shiguangping.com/imgs/20200926115110.image" alt="img" style="zoom:50%;" /><p>“你们看，第一部分是JWT的基本信息，然后把用户的身份信息放在第二部分，接着和第一部分合在一起做一个计算，计算的时候加入了一个只有我们才知道的密钥<code>secretkey</code>，计算结果作为第三部分。最后三部分拼在一起作为最终的token发送给客户端保存着···”</p><p>还没等老三说完，老二点出了其中的关键：“我知道了，后面咱们再收到这个token的时候，就可以通过同样的算法验证前面两部分的结果和第三部分是不是相同，就知道这个token是不是伪造的啦！因为密钥只有我们知道，别人没办法伪造出一个token的！最后确认有效之后，再取第二部分的用户身份信息，就知道这是谁了！”</p><img src="https://images.shiguangping.com/imgs/20200926115118.image" alt="img" style="zoom:50%;" /><p>听完他们的分析，我和Redis老兄都默默的点了点头，“有点意思啊，这样一来，咱们确实不用存了！不过现在咱们几个工作配合的也挺好的，他们费这么大劲是为了什么啊？”</p><p>“我猜他们是想节约开支，把Redis老哥给裁掉！”，老二说到。</p><p>老三摇了摇头，“依我看，八成他们是想展示技术给领导看，这不又快到职级晋升答辩了，他们想搞事情！唉，老大，这事你怎么看？”</p><p>“我啊，我···”</p><p>朋友们，你怎么看？session-cookie和JWT，你更倾向谁？</p><hr><p><strong>转载自：<a href="https://www.cnblogs.com/xuanyuan/p/13722483.html" target="_blank">https://www.cnblogs.com/xuanyuan/p/13722483.html</a></strong></p>]]></content>
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Session-Cookie </tag>
            
            <tag> Token </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>突然挂了！Redis缓存都在内存中，这下完了！</title>
      <link href="/2020/09/redis-story-persistence/"/>
      <url>/2020/09/redis-story-persistence/</url>
      <content type="html"><![CDATA[<p>我是<strong>Redis</strong>，一个叫<strong>Antirez</strong>的男人把我带到了这个世界上。</p><a id="more"></a><img src="https://images.shiguangping.com/imgs/20200926112705.jpg" alt="img" style="zoom:50%;" /><p>“快醒醒！快醒醒！”，隐隐约约，我听到有人在叫我。</p><p>慢慢睁开眼睛，原来旁边是MySQL大哥。</p><p>“我怎么睡着了？”</p><p>“嗨，你刚才是不是出现了错误，整个进程都崩溃了！害得一大堆查询请求都给我怼过来了！”，MySQL说到。</p><p>刚刚醒来，脑子还有点懵，MySQL大哥扶我起来继续工作。</p><p>“糟了！我之前缓存的数据全都不见了！”</p><p>“WTF？你没有做<strong>持久化</strong>吗？”，MySQL大哥一听脸色都变了。</p><p>我尴尬的摇了摇头，“我都是保存在内存中的，所以才那么快啊”</p><p>“那也可以在硬盘上保存一下啊，遇到这种情况全部从头再来建立缓存，这不浪费时间嘛！”</p><img src="https://images.shiguangping.com/imgs/20200926112819.png" alt="img" style="zoom:50%;" /><p>我点了点头，“让我琢磨一下，看看怎么做这个持久化”。</p><h2 id="rdb持久化">RDB持久化<a title="#rdb持久化" href="#rdb持久化"></a></h2><p>没几天，我就拿出了一套方案：<strong>RDB</strong></p><p>既然我的数据都在内存中存放着，最简单的就是遍历一遍把它们全都写入文件中。</p><p>为了节约空间，我定义了一个二进制的格式，把数据一条一条码在一起，生成了一个RDB文件。</p><img src="https://images.shiguangping.com/imgs/20200926112831.png" alt="img" style="zoom:50%;" /><p>不过我的数据量有点大，要是全部备份一次得花不少时间，所以不能太频繁的去做这事，要不然我不用干正事了，光花时间去备份了。</p><p>还有啊，要是一直没有写入操作，都是读取操作，那我也不用重复备份，浪费时间。</p><p>思来想去，我决定提供一个配置参数，既可以支持周期性备份，也可以避免做无用功。</p><p>就像这样：</p><blockquote><ul><li>save 900 1   # 900秒（15分钟）内有1个写入</li><li>save 300 10   # 300秒（5分钟）内有10个写入</li><li>save 60 10000  # 60秒（1分钟）内有10000个写入</li></ul></blockquote><p>多个条件可以组合使用，只要上面一个条件满足，我就会去进行备份。</p><p>后来我又想了一下，这样还是不行，我得<strong>fork</strong>出一个子进程去做这件事，不能浪费我的时间。</p><p>有了备份文件，下次我再遇到崩溃退出，甚至服务器断电罢工了，只要我的备份文件还在，我就能在启动的时候读取，快速恢复之前的状态啦！</p><img src="https://images.shiguangping.com/imgs/20200926112914.png" alt="img" style="zoom:50%;" /><h2 id="mysql:binlog">MySQL:binlog<a title="#mysql:binlog" href="#mysql:binlog"></a></h2><p>我带着这套方案，兴冲冲的拿给了MySQL大哥看了，期待他给我一些鼓励。</p><p>“老弟，你这个方案有点问题啊”，没想到，他竟给我浇了一盆冷水。</p><p>“问题？有什么问题？”</p><p>“你看啊，你这个周期性去备份，周期还是分钟级别的，你可知道咱们这服务每秒钟都要响应多少请求，像你这样不得丢失多少数据？”，MySQL语重心长的说到。</p><img src="https://images.shiguangping.com/imgs/20200926113004.png" alt="img" style="zoom:50%;" /><p>我一下有些气短了，“可是，这个备份一次要遍历全部数据，开销还是挺大的，不适合高频执行啊”</p><p>“谁叫你一次遍历全部数据了？来来来，我给你看个东西”，MySQL大哥把我带到了一个文件目录下：</p><blockquote><ul><li>mysql-bin.000001</li><li>mysql-bin.000002</li><li>mysql-bin.000003</li><li>···</li></ul></blockquote><p>“看，这些是我的<strong>二进制日志binlog</strong>，你猜猜看里面都装了些什么？”，MySQL大哥指着这一堆文件说到。</p><p>我看了一眼，全是一堆二进制数据，这哪看得懂，我摇了摇头。</p><p>“这里面呀记录了我对数据执行更改的所有操作，像是<strong>INSERT</strong>，<strong>UPDATE</strong>、<strong>DELETE</strong>等等动作，等我要进行数据恢复的时候就可以派上大用场了”</p><p>听他这么一说，我一下来了灵感！告别了MySQL大哥，回去研究起新的方案来了。</p><h2 id="aof持久化">AOF持久化<a title="#aof持久化" href="#aof持久化"></a></h2><p>你们也知道，我也是基于命令式的，每天的工作就是响应业务程序发来的命令请求。</p><p>回来以后，我决定照葫芦画瓢，学着MySQL大哥的样子，把我执行的所有写入命令都记录下来，专门写入了一个文件，并给这种持久化方式也取了一个名字：<strong>AOF（Append Only File）</strong>。</p><img src="https://images.shiguangping.com/imgs/20200926113040.png" alt="img" style="zoom:50%;" /><p>不过我遇到了RDB方案同样的问题，我该多久写一次文件呢？</p><p>我肯定不能每执行一条写入命令就记录到文件中，那会严重拖垮我的性能！我决定准备一个缓冲区，然后把要记录的命令先临时保存在这里，然后再择机写入文件，我把这个临时缓冲区叫做<strong>aof_buf</strong>。</p><img src="https://images.shiguangping.com/imgs/20200926113055.png" alt="img" style="zoom:50%;" /><p>说干就干，我试了一下，竟然发现数据没有写入到文件中去。多方打听才知道，原来操作系统也有个缓存区，我写的数据被他缓存起来了，没有给我写入到文件中去，这不是坑爹呢嘛！</p><p>看来，我写完了还得要去刷新一下，把数据真正给写下去，思来想去，我还是提供一个参数，让业务程序去设置什么时候刷新吧。</p><blockquote><p><code>appendfsync</code>参数，三个取值：</p><ul><li>always: 每个事件周期都同步刷新一次</li><li>everysec: 每一秒都同步刷新一次</li><li>no: 我只管写，让操作系统自己决定什么时候真正写入吧</li></ul></blockquote><h2 id="aof重写">AOF重写<a title="#aof重写" href="#aof重写"></a></h2><p>这一次我不像之前那么冲动，我决定先试运行一段时间再去告诉MySQL大哥，免得又被他戳到软肋。</p><p>试用了一段时间，各方面都运行良好，不过我发现随着时间的推移，我写的这个AOF备份文件越来越大，越来越大！不仅非常占硬盘空间，复制移动，加载分析都非常的麻烦耗时。</p><p>我得想个办法把文件给<strong>压缩</strong>一下，我把这个过程叫做<strong>AOF重写</strong>。</p><img src="https://images.shiguangping.com/imgs/20200926113127.png" alt="img" style="zoom:50%;" /><p>一开始，我打算去分析原来的AOF文件，然后将其中的冗余指令去掉，来给AOF文件瘦瘦身，不过我很快放弃了这个想法，这工作量实在太大了，分析起来也颇为麻烦，浪费很多精力跟时间。</p><p>原来的一条条记录这种方式实在是太笨了，数据改来改去，有很多中间状态都没用，我何不就把最终都数据状态记录下来就好了？</p><p>比如：</p><blockquote><ul><li>RPUSH name_list <strong>'编程技术宇宙’</strong></li><li>RPUSH name_list <strong>'帅地玩编程’</strong></li><li>RPUSH name_list <strong>'后端技术学堂’</strong></li></ul><p>可以合并成一条搞定：</p><ul><li>RPUSH name_list <strong>‘编程技术宇宙’</strong> <strong>‘帅地玩编程’</strong> <strong>'后端技术学堂’</strong></li></ul></blockquote><p>AOF文件重写的思路我是有了，不过这件事干起来还是很耗时间，我决定和RDB方式一样，fork出一个子进程来做这件事情。</p><p>谨慎如我，发现这样做之后，子进程在重写期间，我要是修改了数据，就会出现和重写的内容不一致的情况！MySQL大哥肯定会挑刺儿，我还得把这个漏洞给补上。</p><img src="https://images.shiguangping.com/imgs/20200926113153.png" alt="img" style="zoom:50%;" /><p>于是，我在之前的<strong>aof_buf</strong>之外，又准备了一个缓冲区：<strong>AOF重写缓冲区</strong>。</p><p>从创建重写子进程开始的那一刻起，我把后面来的写入命令也copy一份写到这个重写缓冲区中，等到子进程重写AOF文件结束之后，我再把这个缓冲区中的命令写入到新的AOF文件中。</p><p>最后再重命名新的AOF文件，替换掉原来的那个臃肿不堪的大文件，终于大功告成！</p><img src="https://images.shiguangping.com/imgs/20200926113208.png" alt="img" style="zoom:50%;" /><p>再三确定我的思路没有问题之后，我带着新的方案再次找到了MySQL大哥，我都做到这份儿上了，这一次，想必他应该无话可说了吧？</p><p>MySQL大哥看了我的方案露出了满意的笑容，只是问了一个问题：</p><blockquote><p>这AOF方案这么好了，RDB方案是不是可以不要了呢？</p></blockquote><p>万万没想到，他居然问我这个问题，我竟陷入了沉思，你觉得我该怎么回答好呢？</p><hr><p><strong>转载自<a href="https://www.cnblogs.com/xuanyuan/p/13689484.html" target="_blank">https://www.cnblogs.com/xuanyuan/p/13689484.html</a></strong></p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>还不懂Redis？看完这个故事就明白了！</title>
      <link href="/2020/09/redis-story/"/>
      <url>/2020/09/redis-story/</url>
      <content type="html"><![CDATA[<h2 id="我是redis"><strong>我是Redis</strong><a title="#我是redis" href="#我是redis"></a></h2><p>你好，我是Redis，一个叫Antirez的男人把我带到了这个世界上。</p><img src="https://images.shiguangping.com/imgs/20200926111910.jpg" alt="img" style="zoom:50%;" /><p>说起我的诞生，跟关系数据库MySQL还挺有渊源的。</p><p>在我还没来到这个世界上的时候，MySQL过的很辛苦，互联网发展的越来越快，它容纳的数据也越来越多，用户请求也随之暴涨，而每一个用户请求都变成了对它的一个又一个读写操作，MySQL是苦不堪言。尤其是到“双11”、“618“这种全民购物狂欢的日子，都是MySQL受苦受难的日子。</p><p>据后来MySQL告诉我说，其实有一大半的用户请求都是读操作，而且经常都是重复查询一个东西，浪费它很多时间去进行磁盘I/O。</p><p>后来有人就琢磨，是不是可以学学CPU，给数据库也加一个缓存呢？于是我就诞生了！</p><p>出生不久，我就和MySQL成为了好朋友，我们俩常常携手出现在后端服务器中。</p><p>应用程序们从MySQL查询到的数据，在我这里登记一下，后面再需要用到的时候，就先找我要，我这里没有再找MySQL要。</p><img src="https://images.shiguangping.com/imgs/20200926111939.jpg" alt="img" style="zoom:50%;" /><p>为了方便使用，我支持好几种数据结构的存储：</p><ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>SortedSet</li><li>Bitmap</li><li>······</li></ul><p>因为我把登记的数据都记录在内存中，不用去执行慢如蜗牛的I/O操作，所以找我要比找MySQL要省去了不少的时间呢。</p><p>可别小瞧这简单的一个改变，我可为MySQL减轻了不小的负担！随着程序的运行，我缓存的数据越来越多，有相当部分时间我都给它挡住了用户请求，这一下它可乐得清闲自在了！</p><p>有了我的加入，网络服务的性能提升了不少，这都归功于我为数据库挨了不少枪子儿。</p><h2 id="缓存过期-&amp;&amp;-缓存淘汰"><strong>缓存过期 &amp;&amp; 缓存淘汰</strong><a title="#缓存过期-&amp;&amp;-缓存淘汰" href="#缓存过期-&amp;&amp;-缓存淘汰"></a></h2><p>不过很快我发现事情不妙了，我缓存的数据都是在内存中，可是就算是在服务器上，内存的空间资源还是很有限的，不能无节制的这么存下去，我得想个办法，不然吃枣药丸。</p><p>不久，我想到了一个办法：给缓存内容设置一个超时时间，具体设置多长交给应用程序们去设置，我要做的就是把过期了的内容从我里面删除掉，及时腾出空间就行了。</p><img src="https://images.shiguangping.com/imgs/20200926112001.jpg" alt="img" style="zoom:50%;" /><p>超时时间有了，我该在什么时候去干这个清理的活呢？</p><p>最简单的就是定期删除，我决定100ms就做一次，一秒钟就是10次！</p><p>我清理的时候也不能一口气把所有过期的都给删除掉，我这里面存了大量的数据，要全面扫一遍的话那不知道要花多久时间，会严重影响我接待新的客户请求的！</p><img src="https://images.shiguangping.com/imgs/20200926112049.jpg" alt="img" style="zoom:50%;" /><p>时间紧任务重，我只好随机选择一部分来清理，能缓解内存压力就行了。</p><p>就这样过了一段日子，我发现有些个键值运气比较好，每次都没有被我的随机算法选中，每次都能幸免于难，这可不行，这些长时间过期的数据一直霸占着不少的内存空间！气抖冷！</p><p>我眼里可揉不得沙子！于是在原来定期删除的基础上，又加了一招：</p><p>那些原来逃脱我随机选择算法的键值，一旦遇到查询请求，被我发现已经超期了，那我就绝不客气，立即删除。</p><p>这种方式因为是被动式触发的，不查询就不会发生，所以也叫惰性删除！</p><p>可是，还是有部分键值，既逃脱了我的随机选择算法，又一直没有被查询，导致它们一直逍遥法外！而于此同时，可以使用的内存空间却越来越少。</p><img src="https://images.shiguangping.com/imgs/20200926112113.jpg" alt="img" style="zoom:50%;" /><p>而且就算退一步讲，我能够把过期的数据都删除掉，那万一过期时间设置的很长，还没等到我去清理，内存就吃满了，一样要吃枣药丸，所以我还得想个办法。</p><p>我苦思良久，终于憋出了个大招：内存淘汰策略，这一次我要彻底解决问题！</p><p>我提供了8种策略供应用程序选择，用于我遇到内存不足时该如何决策：</p><ul><li>noeviction：返回错误，不会删除任何键值</li><li>allkeys-lru：使用LRU算法删除最近最少使用的键值</li><li>volatile-lru：使用LRU算法从设置了过期时间的键集合中删除最近最少使用的键值</li><li>allkeys-random：从所有key随机删除</li><li>volatile-random：从设置了过期时间的键的集合中随机删除</li><li>volatile-ttl：从设置了过期时间的键中删除剩余时间最短的键</li><li>volatile-lfu：从配置了过期时间的键中删除使用频率最少的键</li><li>allkeys-lfu：从所有键中删除使用频率最少的键</li></ul><p>有了上面几套组合拳，我再也不用担心过期数据多了把空间撑满的问题了~</p><h2 id="缓存穿透-&amp;&amp;-布隆过滤器"><strong>缓存穿透 &amp;&amp; 布隆过滤器</strong><a title="#缓存穿透-&amp;&amp;-布隆过滤器" href="#缓存穿透-&amp;&amp;-布隆过滤器"></a></h2><p>我的日子过的还挺舒坦，不过MySQL大哥就没我这么舒坦了，有时候遇到些烦人的请求，查询的数据不存在，MySQL就要白忙活一场！不仅如此，因为不存在，我也没法缓存啊，导致同样的请求来了每次都要去让MySQL白忙活一场。我作为缓存的价值就没得到体现啦！这就是人们常说的缓存穿透。</p><img src="https://images.shiguangping.com/imgs/20200926112255.jpg" alt="img" style="zoom:50%;" /><p>这一来二去，MySQL大哥忍不住了：“唉，兄弟，能不能帮忙想个办法，把那些明知道不会有结果的查询请求给我挡一下”</p><p>这时我想到了我的另外一个好朋友：布隆过滤器</p><img src="https://images.shiguangping.com/imgs/20200926112306.jpg" alt="img" style="zoom:50%;" /><p>我这位朋友别的本事没有，就擅长从超大的数据集中快速告诉你查找的数据存不存在（悄悄告诉你，我的这位朋友有一点不靠谱，它告诉你存在的话不能全信，其实有可能是不存在的，不过它他要是告诉你不存在的话，那就一定不存在）。</p><img src="https://images.shiguangping.com/imgs/20200926112319.jpg" alt="img" style="zoom:50%;" /><p>我把这位朋友介绍给了应用程序，不存在的数据就不必去叨扰MySQL了，轻松帮忙解决了缓存穿透的问题。</p><h2 id="缓存击穿-&amp;&amp;-缓存雪崩"><strong>缓存击穿 &amp;&amp; 缓存雪崩</strong><a title="#缓存击穿-&amp;&amp;-缓存雪崩" href="#缓存击穿-&amp;&amp;-缓存雪崩"></a></h2><p>这之后过了一段时间太平日子，直到那一天···</p><p>有一次，MySQL那家伙正优哉游哉的摸鱼，突然一大堆请求给他怼了过去，给他打了一个措手不及。</p><p>一阵忙活之后，MySQL怒气冲冲的找到了我，“兄弟，咋回事啊，怎么一下子来的这么猛”</p><img src="https://images.shiguangping.com/imgs/20200926112334.jpg" alt="img" style="zoom:50%;" /><p>我查看了日志，赶紧解释到：“大哥，实在不好意思，刚刚有一个热点数据到了过期时间，被我删掉了，不巧的是随后就有对这个数据的大量查询请求来了，我这里已经删了，所以请求都发到你那里来了”</p><p>“你这干的叫啥事，下次注意点啊”，MySQL大哥一脸不高兴的离开了。</p><p>这一件小事我也没怎么放在心上，随后就抛之脑后了，却没曾想几天之后竟捅了更大的篓子。</p><p>那一天，又出现了大量的网络请求发到了MySQL那边，比上一次的规模大得多，MySQL大哥一会儿功夫就给干趴下了好几次！</p><p>等了好半天这一波流量才算过去，MySQL才缓过神来。</p><p>“老弟，这一次又是什么原因？”，MySQL大哥累的没了力气。</p><p>“这一次比上一次更不巧，这一次是一大批数据几乎同时过了有效期，然后又发生了很多对这些数据的请求，所以比起上一次这规模更大了”</p><img src="https://images.shiguangping.com/imgs/20200926112345.jpg" alt="img" style="zoom:50%;" /><p>MySQL大哥听了眉头一皱，“那你倒是想个办法啊，三天两头折磨我，这谁顶得住啊？”</p><p>“其实我也很无奈，这个时间也不是我设置的，要不我去找应用程序说说，让他把缓存过期时间设置的均匀一些？至少别让大量数据集体失效”</p><p>“走，咱俩一起去”</p><p>后来，我俩去找应用程序商量了，不仅把键值的过期时间随机了一下，还设置了热点数据永不过期，这个问题缓解了不少。哦对了，我们还把这两次发生的问题分别取了个名字：缓存击穿和缓存雪崩。</p><p>我们终于又过上了舒适的日子···</p><p><img src="https://images.shiguangping.com/imgs/20200926112423.jpg" alt="img" class="φcx"></p><hr><p><strong>转载自：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/xuanyuan/p/13665170.html" target="_blank">https://www.cnblogs.com/xuanyuan/p/13665170.html</a></strong></p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue数据变化检测（无法检测对象/数组元素的变化问题）</title>
      <link href="/2020/09/vue-responsive/"/>
      <url>/2020/09/vue-responsive/</url>
      <content type="html"><![CDATA[<p>写代码时遇到这样一个问题，页面打开后进行axios请求数据，将响应回的数据赋值给data()中的一个对象，然后再v-for遍历对象将属性显示到页面中。</p><p>但每次打开页面后要遍历显示的数据都没有显示出来，重新刷新或者点下其它的下拉框，要遍历的元素才显示。</p><p>起初我以为是异步请求的问题，怀疑是先渲染DOM后请求的数据，后来查阅官方文档，原因是Vue无法检测对象和数组的变化。</p><a id="more"></a><h1 id="深入响应式原理">深入响应式原理<a title="#深入响应式原理" href="#深入响应式原理"></a></h1><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters" target="_blank">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 <a href="https://github.com/vuejs/vue-devtools" target="_blank">vue-devtools</a> 来获取对检查数据更加友好的用户界面。</p><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p><img src="https://images.shiguangping.com/imgs/20200924102724.png" alt="data" class="φcx"></p><h2 id="检测变化的注意事项">检测变化的注意事项<a title="#检测变化的注意事项" href="#检测变化的注意事项"></a></h2><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><h3 id="对于对象">对于对象<a title="#对于对象" href="#对于对象"></a></h3><p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。例如，对于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.someObject,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="built_in">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.someObject, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="对于数组">对于数组<a title="#对于数组" href="#对于数组"></a></h3><p>Vue 不能检测以下数组的变动：</p><ol><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>你也可以使用 <a href="https://cn.vuejs.org/v2/api/#vm-set" target="_blank"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 <code>splice</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="声明响应式-property">声明响应式 property<a title="#声明响应式-property" href="#声明响应式-property"></a></h2><p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 声明 message 为一个空值字符串</span></span><br><span class="line">    message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 之后设置 `message`</span></span><br><span class="line">vm.message = <span class="string">&#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure><p>如果你未在 <code>data</code> 选项中声明 <code>message</code>，Vue 将警告你渲染函数正在试图访问不存在的 property。</p><p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：<code>data</code> 对象就像组件状态的结构 (schema)。提前声明所有的响应式 property，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解。</p><h2 id="异步更新队列">异步更新队列<a title="#异步更新队列" href="#异步更新队列"></a></h2><p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><p>例如，当你设置 <code>vm.someData = 'new value'</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = <span class="string">&#x27;new message&#x27;</span> <span class="comment">// 更改数据</span></span><br><span class="line">vm.$el.textContent === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// false</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el.textContent === <span class="string">&#x27;new message&#x27;</span> <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank">ES2017 async/await</a> 语法完成相同的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  updateMessage: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.$nextTick()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方原文：<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><hr><p>因为我请求的数据赋值给一个对象，Vue无法检测对象中的属性变化，所以可以使用<code>this.$set(object, propertyName, value)</code>这种形式将响应回的数据赋值给data()中的对象。</p>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue验证表单字段常用规则</title>
      <link href="/2020/09/vue-form-validator/"/>
      <url>/2020/09/vue-form-validator/</url>
      <content type="html"><![CDATA[<p>项目代码使用的element-ui</p><p><strong>1. 页面表单添加验证属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--el-form中要绑定model;el-form-item绑定prop属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">org</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>el-form中<code>rules</code>属性对应data()中的rules校验对象</p></li><li><p>el-form-item中<code>prop</code>属性对应的rules对象中的属性</p></li></ul><p><strong>2. rules是一个验证规则对象,因此需要在data()页面数据里添加rules对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">        name: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="built_in">this</span>.$t(<span class="string">&#x27;rules.require&#x27;</span>), <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;],</span><br><span class="line">        password: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="built_in">this</span>.$t(<span class="string">&#x27;rules.require&#x27;</span>), <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 创建全局验证规则my-validate.js，供页面灵活引入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 验证账号 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateUsername</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value.length &lt; <span class="number">6</span> || value.length &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;用户名不得小于6个或大于20个字符!&#x27;</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 验证密码 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validatePassword</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;密码不能小于6位&#x27;</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 合法邮箱 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateEmail</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emailReg = <span class="regexp">/^(([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]&#123;2,5&#125;)&#123;1,25&#125;)$/</span></span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱不能为空!!&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!emailReg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱格式错误&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 合法手机号 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validatePhone</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> phoneReg = <span class="regexp">/^[1][3,4,5,7,8][0-9]&#123;9&#125;$/</span></span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手机号码不能为空!!&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!phoneReg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;手机号码格式错误&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 合法真实姓名 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateRealName</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> realnameReg = <span class="regexp">/^([a-zA-Z0-9\u4e00-\u9fa5\·]&#123;1,10&#125;)$/</span></span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;真实姓名不能为空!!&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!realnameReg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;您的真实姓名格式错误,请输入英文或汉字!&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 合法身份证 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateIdNumber</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> idNumberReg = <span class="regexp">/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$|^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;([0-9]|X)$/</span></span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;身份证号码不能为空!!&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idNumberReg.test(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;您的身份证号码格式错误!&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验营业执照注册号/统一社会信用代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">rule</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">validateBusinessLicense</span>(<span class="params">rule, value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value.length === <span class="number">15</span> || value.length === <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length === <span class="number">15</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> ti = <span class="number">0</span></span><br><span class="line">      <span class="keyword">let</span> si = <span class="number">0</span><span class="comment">// pi|11+ti</span></span><br><span class="line">      <span class="keyword">let</span> cj = <span class="number">0</span><span class="comment">// （si||10==0？10：si||10）*2</span></span><br><span class="line">      <span class="keyword">let</span> pj = <span class="number">10</span><span class="comment">// pj=cj|11==0?10:cj|11</span></span><br><span class="line">      <span class="keyword">let</span> lastNum = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        ti = <span class="built_in">parseInt</span>(value[i])</span><br><span class="line">        si = pj + ti</span><br><span class="line">        cj = (si % <span class="number">10</span> === <span class="number">0</span> ? <span class="number">10</span> : si % <span class="number">10</span>) * <span class="number">2</span></span><br><span class="line">        pj = cj % <span class="number">11</span></span><br><span class="line">        <span class="keyword">if</span> (i === value.length - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// lastNum =(1 - pj &lt; 0 ? 11 - pj : 1 - pj) % 10;</span></span><br><span class="line">          lastNum = si % <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lastNum === <span class="number">1</span>) &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callback(<span class="string">&#x27;营业执照注册号不正确&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.length === <span class="number">18</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">&#x27;0123456789ABCDEFGHJKLMNPQRTUWXY&#x27;</span></span><br><span class="line">      <span class="keyword">var</span> ws = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">29</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">28</span>]</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-array-constructor</span></span><br><span class="line">      <span class="keyword">var</span> codes = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">      codes[<span class="number">0</span>] = value.substr(<span class="number">0</span>, value.length - <span class="number">1</span>)</span><br><span class="line">      codes[<span class="number">1</span>] = value.substr(value.length - <span class="number">1</span>, value.length)</span><br><span class="line">      <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;</span><br><span class="line">        sum += str.indexOf(codes[<span class="number">0</span>].charAt(i)) * ws[i]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> c18 = <span class="number">31</span> - (sum % <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">if</span> (c18 === <span class="number">31</span>) &#123;</span><br><span class="line">        c18 = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c18 === <span class="number">30</span>) &#123;</span><br><span class="line">        c18 = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (str.charAt(c18) !== codes[<span class="number">1</span>].charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        callback(<span class="string">&#x27;统一社会信用代码不正确&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback(<span class="string">&#x27;号码位数不正确&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 引入全局验证脚本</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; validateBusinessLicense &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/my-validate&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>5. 在rules对象中使用引入的校验规则</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unifyCode: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">validator</span>: validateBusinessLicense, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker部署nacos单机版</title>
      <link href="/2020/09/docker-nacos-standalone/"/>
      <url>/2020/09/docker-nacos-standalone/</url>
      <content type="html"><![CDATA[<h2 id="创建nacos容器">创建nacos容器<a title="#创建nacos容器" href="#创建nacos容器"></a></h2><ul><li><p>搜索镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nacos</span><br></pre></td></tr></table></figure></li><li><p>拉取镜像到本地（未指定版本默认拉取远程仓库中的最新版）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure></li><li><p>新建nacos容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos -d -p 8848:8848 nacos/nacos-server</span><br></pre></td></tr></table></figure><p><code>env</code>参数是指容器所处的环境，这里是指建立单机版的nacos</p></li></ul><h2 id="配置数据库">配置数据库<a title="#配置数据库" href="#配置数据库"></a></h2><ul><li><p>创建数据库（默认使用mysql数据库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database nacos_config;</span><br></pre></td></tr></table></figure></li><li><p>导入sql脚本，<a href="https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql" target="_blank">到官网复制</a></p></li><li><p>修改nacos配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nacos /bin/sh; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p><code>nacos</code>为容器名称，进入交互模式，进入conf目录，可以使用vim编辑nacos配置文件<code>application.properties</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改端口号（默认是8848）</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="comment"># 数据库的url/user/pass</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><code>db.url.1</code>用于配置从数据库，不需要先注释掉</p></li></ul><p>以上都配置完之后重启容器，访问<a href="http://localhost:8001/nacos" target="_blank">http://localhost:8001/nacos</a>，显示登陆页面，用户名和密码默认都是<code>nacos</code>。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring-Cloud-Alibaba </tag>
            
            <tag> Spring-Cloud </tag>
            
            <tag> 服务注册与发现 </tag>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue组件间通信</title>
      <link href="/2020/09/vue-components-communication/"/>
      <url>/2020/09/vue-components-communication/</url>
      <content type="html"><![CDATA[<p>Vue组件间通信的两种常见情况：</p><ul><li>父子组件间通信<ul><li>父传子</li><li>子传父</li></ul></li><li>非父子组件间通信</li></ul><a id="more"></a><h3 id="父子组件间通信：">父子组件间通信：<a title="#父子组件间通信：" href="#父子组件间通信："></a></h3><p>父子组件通信很简单，父组件会通过 <code>props</code> 向下传数据给子组件，当子组件有事情要告诉父组件时会通过 <code>$emit</code> 事件告诉父组件。</p><p>这里拿element-ui中的对话框dialog举例，定义两个组件，<code>Index.vue</code>和<code>Dialog.vue</code>。Index中有一个按钮，点击按钮，将<code>dialog.isVisible=true</code>带到子组件中，打开对话框；在子组件中点击关闭按钮，再关闭对话框。关闭时，需要在子组件调用父组件中的方法，将父组件中的属性<code>dialog.isVisible</code>置为<code>false</code>。</p><p><code>Dialog.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-dialog</span><br><span class="line">        :title&#x3D;&quot;title&quot;</span><br><span class="line">        :visible.sync&#x3D;&quot;isVisible&quot;</span><br><span class="line">        width&#x3D;&quot;30%&quot;&gt;</span><br><span class="line">      &lt;span&gt;message:&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;close&quot; type&#x3D;&quot;primary&quot;&gt;关 闭&lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;dialog&quot;,</span><br><span class="line">  &#x2F;&#x2F; props:定义组件的属性，父组件通过props中定义的属性将值传过来。也就是说父组件只能向子组件中props定义的属性传值</span><br><span class="line">  props: &#123;</span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 当组件属性发生改变时返回最新的值</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isVisible() &#123;</span><br><span class="line">      return this.visible</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    close() &#123;</span><br><span class="line">      &#x2F;&#x2F; 子组件调用父组件方法，定义close事件，当dialog关闭时，调用父组件定义的方法&lt;Dialog @close&#x3D;&quot;xxx&quot;&#x2F;&gt;，调用父组件中的xxx方法</span><br><span class="line">      this.$emit(&#39;close&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 该方法在父组件中通过$refs.dialog.initMsg()的形式调用</span><br><span class="line">    initMsg()&#123;</span><br><span class="line">      this.msg &#x3D; &#39;父组件调用子组件方法&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>Index.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;dialogOpen&quot;&gt;打开对话框&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">visible：是子组件props中定义的属性，父组件通过通过这种形式将值带到子组件中</span><br><span class="line">title：也是同理</span><br><span class="line">@close&#x3D;&quot;dialogClose&quot;：@close是子组件Dialog自定义的事件。当Dialog关闭时，子组件中执行this.$emit(&#39;close&#39;)，调用父组件中的dialogClose()方法</span><br><span class="line">ref：官方的解释是用来给元素或子组件注册一个引用，该引用会绑定到父组件的$refs对象上。如果在普通DOM元素上使用，引用指向的是DOM元素；如果用在子组件上，引用就是指向子组件的实例。</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;Dialog :visible&#x3D;&quot;dialog.isVisible&quot; :title&#x3D;&quot;dialog.title&quot; @close&#x3D;&quot;dialogClose&quot; ref&#x3D;&quot;dialog&quot;&gt;&lt;&#x2F;Dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Dialog from &#39;.&#x2F;components&#x2F;Dialog&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;index&quot;,</span><br><span class="line">  components: &#123;Dialog&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dialog: &#123;</span><br><span class="line">        isVisible: false,</span><br><span class="line">        title: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dialogOpen() &#123;</span><br><span class="line">      this.dialog.title &#x3D; &#39;父传子&#39;</span><br><span class="line">      &#x2F;&#x2F; 父组件调用子组件方法，通过ref属性指向子组件实例，调用子组件中的方法</span><br><span class="line">      this.$refs.dialog.initMsg()</span><br><span class="line">      this.dialog.isVisible &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    dialogClose() &#123;</span><br><span class="line">      this.dialog.isVisible &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="非父子组件间通信：">非父子组件间通信：<a title="#非父子组件间通信：" href="#非父子组件间通信："></a></h3><p><img src="https://images.shiguangping.com/imgs/20200920164317.jpg" alt="img" class="φcx"></p><p>如果我们不需要类似Vuex这样的库来处理组件之间的数据通信，就可以考虑Vue中的 <code>事件总线</code> ，即 <code>EventBus</code>来通信。</p><p><strong>EventBus的简介</strong></p><p><code>EventBus</code> 又称为事件总线。在Vue中可以使用 <code>EventBus</code> 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。</p><p><strong>如何使用EventBus</strong></p><p><strong>一、初始化</strong><br>首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来处理。先来看第一种，新创建一个 .js 文件，比如 <code>event-bus.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>实质上<code>EventBus</code>是一个不具备 <code>DOM</code> 的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便。</p><p>另外一种方式，可以直接在项目中的 <code>main.js</code> 初始化 <code>EventBus</code> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><p>注意，这种方式初始化的<code>EventBus</code>是一个<code>全局的事件总线</code>。</p><p>现在我们已经创建了 <code>EventBus</code> ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。</p><p><strong>二、发送事件</strong></p><p><img src="https://images.shiguangping.com/imgs/20200920164616.jpg" alt="img" class="φcx"></p><p>假设你有两个Vue页面需要通信： A 和 B ，A页面 在按钮上面绑定了点击事件，发送一则消息，想通知 B页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;sendMsg()&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">import &#123; EventBus &#125; from &quot;..&#x2F;event-bus.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMsg() &#123;</span><br><span class="line">      EventBus.$emit(&quot;aMsg&quot;, &#39;来自A页面的消息&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>接下来，我们需要在 B页面 中接收这则消息。</p><p><strong>三、接收事件</strong></p><p><img src="https://images.shiguangping.com/imgs/20200920164707.jpg" alt="img" class="φcx"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- IncrementCount.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">import &#123; EventBus &#125; from &quot;..&#x2F;event-bus.js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    EventBus.$on(&quot;aMsg&quot;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; A发送来的消息</span><br><span class="line">      this.msg &#x3D; msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>同理我们也可以在 B页面 向 A页面 发送消息。这里主要用到的两个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">EventBus.$emit(channel: string, callback(payload1,…))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息</span></span><br><span class="line">EventBus.$on(channel: string, callback(payload1,…))</span><br></pre></td></tr></table></figure><p>前面提到过，如果使用不善，<code>EventBus</code>会是一种灾难，到底是什么样的<code>“灾难”</code>了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的<code>EventBus</code>会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，<code>EventBus</code>在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理<code>EventBus</code>在项目中的关系。通常会用到，在vue页面销毁时，同时移除<code>EventBus</code>事件监听。</p><p><strong>移除事件监听者</strong></p><p><img src="https://images.shiguangping.com/imgs/20200920164847.jpg" alt="img" class="φcx"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eventBus &#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span><br><span class="line"></span><br><span class="line">EventBus.$off(<span class="string">&#x27;aMsg&#x27;</span>, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>EventBus.$off('aMsg')</code> 来移除应用内所有对此某个事件的监听。或者直接调用 <code>EventBus.$off()</code> 来移除所有事件频道，不需要添加任何参数 。</p><p>上面就是 <code>EventBus</code> 的使用方法，是不是很简单。上面的示例中我们也看到了，每次使用 <code>EventBus</code> 时都需要在各组件中引入 <code>event-bus.js</code> 。事实上，我们还可以通过别的方式，让事情变得简单一些。那就是创建一个全局的 <code>EventBus</code> 。接下来的示例向大家演示如何在Vue项目中创建一个全局的 <code>EventBus</code> 。</p><p><strong>全局EventBus</strong></p><p>它的工作原理是发布/订阅方法，通常称为 <code>Pub/Sub</code> 。</p><p><strong>创建全局EventBus</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">  $bus: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> EventBus</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个特定的总线中使用两个方法<code>$on</code>和<code>$emit</code>。一个用于创建发出的事件，它就是<code>$emit</code>；另一个用于订阅<code>$on</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;nameOfEvent&#x27;</span>, &#123; ... pass some event data ...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;nameOfEvent&#x27;</span>,<span class="function">(<span class="params">$event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们可以在某个Vue页面使用<code>this.$bus.$emit(&quot;sendMsg&quot;, '我是web秀');</code>，另一个Vue页面使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;updateMessage&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 我是web秀</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时也可以使用<code>this.$bus.$off('sendMsg')</code>来移除事件监听。</p><p><strong>总结</strong></p><p>本文主要通过简单的实例学习了Vue中有关于 <code>EventBus</code> 相关的知识点。主要涉及了 <code>EventBus</code> 如何实例化，又是如何通过 <code>$emit</code> 发送频道信号，又是如何通过 <code>$on</code> 来接收频道信号。最后简单介绍了如何创建全局的 <code>EventBus</code> 。从实例中我们可以了解到， <code>EventBus</code> 可以较好的实现兄弟组件之间的数据通讯。</p>]]></content>
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Spring Cloud Feign上传文件</title>
      <link href="/2020/09/feign-upload/"/>
      <url>/2020/09/feign-upload/</url>
      <content type="html"><![CDATA[<p>使用Spring Cloud Feign上传文件，早期的Spring Cloud中，Feign本身是没有上传文件的能力的，要想实现这一点，需要自己编写<code>Encoder</code>去实现上传。现在，Feign官方提供了子项目<a href="https://github.com/OpenFeign/feign-form" target="_blank">feign-form</a>，其中实现了上传所需的<code>Encoder</code>。</p><a id="more"></a><blockquote><p>注：笔者测试的版本是Edgware.RELEASE。Camden、Dalston同样适应本文所述。</p></blockquote><h2 id="加依赖">加依赖<a title="#加依赖" href="#加依赖"></a></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写feign-client">编写Feign Client<a title="#编写feign-client" href="#编写feign-client"></a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;ms-content-sample&quot;, configuration = UploadFeignClient.MultipartSupportConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UploadFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST,</span></span><br><span class="line"><span class="meta">            produces = &#123;MediaType.APPLICATION_JSON_UTF8_VALUE&#125;,</span></span><br><span class="line"><span class="meta">            consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">handleFileUpload</span><span class="params">(<span class="meta">@RequestPart(value = &quot;file&quot;)</span> MultipartFile file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultipartSupportConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SpringFormEncoder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，在这个Feign Client中，我们引用了配置类<code>MultipartSupportConfig</code>，在<code>MultipartSupportConfig</code>中，我们实例化了<code>SpringFormEncoder</code>。这样这个Feign Client就能够上传了。</p><p><strong>注意点：</strong></p><ul><li><pre><code class="language-java">@RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST,            produces = &#123;MediaType.APPLICATION_JSON_UTF8_VALUE&#125;,            consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</code></pre><p>这里的<code>produces</code>、<code>consumes</code>不能少；</p></li><li><p>方法参数列表中的注解<code>@RequestPart(value = &quot;file&quot;)</code>不能写成<code>@RequestParam(value = &quot;file&quot;)</code>；</p></li><li><p>最好将Hystrix的超时时间设长一点，例如5秒，否则可能文件还没上传完，Hystrix就超时了，从而导致客户端侧的报错。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring-Cloud-Alibaba </tag>
            
            <tag> Spring-Cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IDEA中的Web项目移动到Eclipse</title>
      <link href="/2020/06/ideaproj-to-eclipse/"/>
      <url>/2020/06/ideaproj-to-eclipse/</url>
      <content type="html"><![CDATA[<h3 id="1.-在idea中，打开模块设置：">1. 在IDEA中，打开模块设置：<a title="#1.-在idea中，打开模块设置：" href="#1.-在idea中，打开模块设置："></a></h3><img src="https://images.shiguangping.com/imgs/20200601222200.png" alt="image-20200601222200817" width="500px" /><p>在模块设置中，将依赖存储格式改为Eclipse：</p><img src="https://images.shiguangping.com/imgs/20200601222414.png" alt="image-20200601222414387" width="500px" /><h3 id="2.-在eclipse中导入项目：（file--&gt;import）">2. 在Eclipse中导入项目：（File–&gt;Import）<a title="#2.-在eclipse中导入项目：（file--&gt;import）" href="#2.-在eclipse中导入项目：（file--&gt;import）"></a></h3><img src="https://images.shiguangping.com/imgs/20200601222710.png" alt="image-20200601222710166" width="500px" /><p>下一步，然后选择项目路径，完成导入：</p><img src="https://images.shiguangping.com/imgs/20200601223017.png" alt="image-20200601223017267" width="500px" /><h3 id="3.-修改项目相关设置，勾选成动态web模块">3. 修改项目相关设置，勾选成动态Web模块<a title="#3.-修改项目相关设置，勾选成动态web模块" href="#3.-修改项目相关设置，勾选成动态web模块"></a></h3><p>项目右键–&gt;properties中：</p><img src="https://images.shiguangping.com/imgs/20200601223242.png" alt="image-20200601223242735" width="650px" /><h3 id="4.-缺少tomcat依赖：">4. 缺少Tomcat依赖：<a title="#4.-缺少tomcat依赖：" href="#4.-缺少tomcat依赖："></a></h3><p>完成上述步骤之后，发现Servlet类中跟Servlet有关的代码报错，则大概是因为缺少Tomcat依赖导致的。此时，通过项目build path config中添加Tomcat库即可：</p><img src="https://images.shiguangping.com/imgs/20200601223822.png" alt="image-20200601223822121" width="650px" /><p><em>完成上述步骤之后，把项目Add到Tomcat容器中，运行Tomcat，此时项目应该可以正常跑起来了~</em></p><hr><p><em>@Author liyan</em></p><p><em>@blog <a href="https://www.shiguangping.com" target="_blank">shiguangping.com</a></em></p><p><em>@Date 2020-6-1</em></p>]]></content>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac OS下安装和配置Maven</title>
      <link href="/2020/05/macos-maven/"/>
      <url>/2020/05/macos-maven/</url>
      <content type="html"><![CDATA[<h3 id="1.-下载maven">1. 下载Maven<a title="#1.-下载maven" href="#1.-下载maven"></a></h3><ol><li><p>打开Maven官方下载网页：<a href="http://maven.apache.org/download.cgi" target="_blank">http://maven.apache.org/download.cgi</a></p><img src="https://images.shiguangping.com/imgs/20200511145456.png" alt="image-20200511145456074" style="zoom:50%;" /></li><li><p>解压下载的压缩包放到自己喜欢的目录下，<em>（放到一个固定的目录，不要随意改动）</em></p><p>比如：/Users/liyan/Documents/CodeRepositorise/apache-maven-3.6.3</p><p><img src="https://images.shiguangping.com/imgs/20200511150127.png" alt="image-20200511150127552" class="φcx"></p></li></ol><h3 id="2.-配置环境变量">2. 配置环境变量<a title="#2.-配置环境变量" href="#2.-配置环境变量"></a></h3><ol><li><p>打开终端，输入一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><p>打开.bash_profile文件，添加环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M2_HOME&#x3D;&#x2F;Users&#x2F;liyan&#x2F;Documents&#x2F;CodeRepositorise&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin </span><br></pre></td></tr></table></figure><p><img src="https://images.shiguangping.com/imgs/20200511150521.png" alt="image-20200511150521799" class="φcx"></p><p>添加好之后保存并退出，执行下面的命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="3.-查看配置是否生效">3. 查看配置是否生效<a title="#3.-查看配置是否生效" href="#3.-查看配置是否生效"></a></h3><ol><li><p>在终端输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p><img src="https://images.shiguangping.com/imgs/20200511150731.png" alt="image-20200511150731453" class="φcx"></p><p><em><strong>到这里，Maven配置成功</strong></em></p></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设置eclipse格式化时不对注释进行格式化</title>
      <link href="/2020/04/eclipse-format-code/"/>
      <url>/2020/04/eclipse-format-code/</url>
      <content type="html"><![CDATA[<h3 id="1.-设置保存时自动格式化">1. 设置保存时自动格式化<a title="#1.-设置保存时自动格式化" href="#1.-设置保存时自动格式化"></a></h3><p><img src="https://images.shiguangping.com/imgs/20200426152326.png" alt="" class="φcx"></p><h3 id="2.-自建代码格式化风格">2. 自建代码格式化风格<a title="#2.-自建代码格式化风格" href="#2.-自建代码格式化风格"></a></h3><p>我用的工具是STS，自带三种代码格式化风格文件；</p><p><img src="https://images.shiguangping.com/imgs/20200426152445.png" alt="" class="φcx"></p><p>这三种风格是不能编辑的，所以我们需要<code>new</code>，自建风格。</p><p><img src="https://images.shiguangping.com/imgs/20200426152755.png" alt="" class="φcx"></p><ul><li>自建的风格名字自定义</li><li>自建风格可以选择系统自带的默认的风格样式</li></ul><h3 id="3.-格式化时不对注释进行格式化">3. 格式化时不对注释进行格式化<a title="#3.-格式化时不对注释进行格式化" href="#3.-格式化时不对注释进行格式化"></a></h3><p><img src="https://images.shiguangping.com/imgs/20200426152803.png" alt="" class="φcx"></p><p><code>Edit</code>编辑刚刚新建的风格，在<strong>Comments</strong>，即把上图中红框内的两个勾选框勾掉，取消对文档注释和块注释的格式化。</p><p><em><strong>格式化的其它功能可以自行尝试</strong></em></p>]]></content>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阶段性学习笔记</title>
      <link href="/2020/04/java-note/"/>
      <url>/2020/04/java-note/</url>
      <content type="html"><![CDATA[<h4 id="目录：">目录：<a title="#目录：" href="#目录："></a></h4><ol><li><a href="https://javabook.shiguangping.com" target="_blank">Java学习笔记-随着学习进度持续更新</a></li><li><a href="https://thymeleaf.shiguangping.com/" target="_blank">Thymeleaf入门教程</a>，作者<a href="https://waylau.com/" target="_blank">waylau</a></li><li><a href="https://mianshi.shiguangping.com/" target="_blank">Java面试题汇总</a>，原文作者<a href="https://juejin.im/user/2506542243918030" target="_blank">小杰要吃蛋</a>，背题过程中我又添加了部分内容</li></ol><hr><p>其他笔记正在整理当中</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>eclipse实现自动补全</title>
      <link href="/2020/04/eclipse-auto-completion/"/>
      <url>/2020/04/eclipse-auto-completion/</url>
      <content type="html"><![CDATA[<p>eclipse设置自动补全：</p><a id="more"></a><p>Window -&gt; Preference中：</p><img src="https://images.shiguangping.com/imgs/20200421150151.png" width="500px"/><p>按照上图红框修改，将<code>Auto activation triggers for Java</code>的值成：<code>.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code>，并将<code>Auto activation delay</code>的值改为<code>200</code>。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java编译运行时报错尝试解决办法</title>
      <link href="/2020/04/java-compile-error/"/>
      <url>/2020/04/java-compile-error/</url>
      <content type="html"><![CDATA[<p>&quot;Description Resource Path Location Type Java compiler level does not match the version of&quot;解决办法<br>project编译问题，需要有三处的jdk版本保持一致，才能编译通过。</p><ol><li><p>在右键项目–&gt;properties–&gt;project Facets–&gt;修改右侧Java的version，要与当前项目jdk版本保持一致</p><p><img src="https://images.shiguangping.com/imgs/20200420161608.png" alt="" class="φcx"></p></li><li><p>设置选项preference–&gt;java–&gt;Compiler–&gt;设置的右侧的Compiler compliance level</p><p><img src="https://images.shiguangping.com/imgs/20200420162147.jpg" alt="" class="φcx"></p><p><em>这一步有的时候不匹配也能编译运行通过</em></p></li><li><p>preferences–&gt;java–&gt;Installed JREs–&gt;设置或者选择右侧的Installed JREs</p><p><img src="https://images.shiguangping.com/imgs/20200420162237.jpg" alt="" class="φcx"></p><p><em>这里就是jre环境路径</em></p></li></ol><p><em><strong>说明：</strong></em><br><em><strong>这个报错的解决办法，首先检查前两步骤，第一步骤修改完之后会解决当前项目的报错问题，程序可以正常编译运行，但是再新建项目之后，任然会出现该问题；第二步骤修改完之后，可以解决新项目报错问题，避免每次新建项目都需要手动去修改第一步骤；第三步就是当前jdk的开发环境，这个一般都没问题。</strong></em></p>]]></content>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下的Vim使用教程</title>
      <link href="/2020/04/vim-help/"/>
      <url>/2020/04/vim-help/</url>
      <content type="html"><![CDATA[<h3 id="什么是vim？">什么是Vim？<a title="#什么是vim？" href="#什么是vim？"></a></h3><p>Vim是从Vi发展出来的一个功能非常强大的文本编辑器，在程序员中广泛使用。</p><h3 id="vim/vi的使用">Vim/Vi的使用<a title="#vim/vi的使用" href="#vim/vi的使用"></a></h3><p>基本上Vim/Vi共分为三种模式：分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><h4 id="命令模式：">命令模式：<a title="#命令模式：" href="#命令模式："></a></h4><p>用户进入Vim时即是<strong>命令模式</strong>。</p><h4 id="输入模式：">输入模式：<a title="#输入模式：" href="#输入模式："></a></h4><p>在命令模式下按 **“ i ”**进入输入模式。</p><p>输入模式下按**“ ESC ”**，退出到命令模式。</p><h4 id="底线命令模式：">底线命令模式：<a title="#底线命令模式：" href="#底线命令模式："></a></h4><p>在命令模式下按**“ ：“**（英文状态下的冒号），进入底线命令模式。</p><p>在底线命令模式下可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按**” ESC “ ** 键退出底线命令模式。</p><p>Vim工作模式：</p><p><code>vim filename</code>进入<code>命令模式</code></p><p><code>i</code>进入<code>输入模式</code></p><p><code>esc</code>退出到<code>命令模式</code></p><p><code>:</code>命令模式下按冒号进入到<code>底线命令模式</code></p><p><code>:wq</code>保存并退出Vim</p><h4 id="常见命令：">常见命令：<a title="#常见命令：" href="#常见命令："></a></h4>]]></content>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>L2TP/IPSec一键安装脚本</title>
      <link href="/2020/03/l2tp/"/>
      <url>/2020/03/l2tp/</url>
      <content type="html"><![CDATA[<h4 id="本脚本适用环境：">本脚本适用环境：<a title="#本脚本适用环境：" href="#本脚本适用环境："></a></h4><p>系统支持：CentOS6+，Debian7+，Ubuntu12+<br>内存要求：≥128M<br>更新日期：2017 年 05 月 28 日</p><h4 id="关于本脚本：">关于本脚本：<a title="#关于本脚本：" href="#关于本脚本："></a></h4><p>名词解释如下<br>L2TP（Layer 2 Tunneling Protocol）<br>IPSec（Internet Protocol Security）<br>IKEv2 (Internet Key Exchange v2)<br>能实现 IPsec 的目前总体上有 openswan，libreswan，strongswan 这3种。<br>libreswan 是基于 openswan 的 fork，所以现在各个发行版基本已经看不到 openswan 的身影了。<br>当然也有使用 strongswan 的。</p><p>之所以要更新 L2TP 一键安装脚本，是因为随着各个 Linux 发行版不断推陈出新，原有的脚本已经不适应现在的需求。<br>本脚本通过编译安装最新版 libreswan 来实现 IPSec（CentOS7 下则是全部 yum 安装），yum 或 apt-get 来安装 xl2tpd，再根据各个发行版的使用方法不同，部署防火墙规则。</p><h4 id="写在前面：">写在前面：<a title="#写在前面：" href="#写在前面："></a></h4><p>基于 OpenVZ 虚拟化技术的 VPS 需要开启TUN/TAP才能正常使用，购买 VPS 时请先咨询服务商是否支持开启 TUN/TAP。</p><p>OpenVZ 虚拟的 VPS 需要系统内核支持 IPSec 才行。也就是说，母服务器的内核如果不支持的话那就没办法，只能换 VPS。<br>因此，一般不建议在 OpenVZ 的 VPS 上安装本脚本。脚本如果检测到该 VPS 为 OpenVZ 架构，会出现警告提醒。</p><h6 id="如何检测是否支持tun模块？">如何检测是否支持TUN模块？<a title="#如何检测是否支持tun模块？" href="#如何检测是否支持tun模块？"></a></h6><p>执行命令：<br><code>cat /dev/net/tun</code><br>如果返回信息为：<br>cat: /dev/net/tun: File descriptor in bad state<br>说明正常</p><h6 id="如何检测是否支持ppp模块？">如何检测是否支持ppp模块？<a title="#如何检测是否支持ppp模块？" href="#如何检测是否支持ppp模块？"></a></h6><p>执行命令：<br><code>cat /dev/ppp</code><br>如果返回信息为：cat: /dev/ppp: No such device or address 说明正常</p><p>当然，脚本在安装时也会执行检查，如果不适用于安装，脚本会予以提示。</p><h4 id="使用方法：">使用方法：<a title="#使用方法：" href="#使用方法："></a></h4><p>root 用户登录后，运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;across&#x2F;master&#x2F;l2tp.sh</span><br><span class="line">chmod +x l2tp.sh</span><br><span class="line">.&#x2F;l2tp.sh</span><br></pre></td></tr></table></figure><p>执行后，会有如下交互界面<br><img src="https://teddysun.com/wp-content/uploads/2016/l2tp_1.png" width=400></p><p>Please input IP-Range:<br>(Default Range: 192.168.18):<br>输入本地IP段范围（本地电脑连接到VPS后给分配的一个本地IP地址），直接回车意味着输入默认值192.168.18</p><p>Please input PSK:<br>(Default PSK: <a href="http://teddysun.com">teddysun.com</a>):<br>PSK意为预共享密钥，即指定一个密钥将来在连接时需要用到，<a href="http://xn--teddysun-273my9g0rmhqhcy9a0thos9e48aq12uveosyae38u.com">直接回车意味着输入默认值teddysun.com</a></p><p>Please input Username:<br>(Default Username: teddysun):<br>Username意为用户名，即第一个默认用户。直接回车意味着输入默认值teddysun</p><p>Please input teddysun’s password:<br>(Default Password: Q4SKhu2EXQ):<br>输入用户的密码，默认会随机生成一个10位包含大小写字母和数字的密码，当然你也可以指定密码。</p><p>ServerIP:your_server_main_IP<br>显示你的 VPS 的主 IP（如果是多 IP 的 VPS 也只显示一个）</p><p>Server Local IP:192.168.18.1<br>显示你的 VPS 的本地 IP（默认即可）</p><p>Client Remote IP Range:192.168.18.2-192.168.18.254<br>显示 IP 段范围</p><p>PSK:teddysun.com<br>显示 PSK</p><p>Press any key to start…or Press Ctrl+c to cancel<br>按下任意按键继续，如果想取消安装，请按Ctrl+c键</p><p>安装完成后，脚本会执行 ipsec verify 命令并提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">If there are no [FAILED] above, then you can connect to your</span><br><span class="line">L2TP VPN Server with the default Username&#x2F;Password is below:</span><br><span class="line"></span><br><span class="line">ServerIP:your_server_IP</span><br><span class="line">PSK:your PSK</span><br><span class="line">Username:your usename</span><br><span class="line">Password:your password</span><br><span class="line"></span><br><span class="line">If you want to modify user settings, please use command(s):</span><br><span class="line">l2tp -a (Add a user)</span><br><span class="line">l2tp -d (Delete a user)</span><br><span class="line">l2tp -l (List all users)</span><br><span class="line">l2tp -m (Modify a user password)</span><br><span class="line">Welcome to visit https:&#x2F;&#x2F;teddysun.com&#x2F;448.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>如果你要想对用户进行操作，可以使用如下命令：<br>l2tp -a 新增用户<br>l2tp -d 删除用户<br>l2tp -m 修改现有的用户的密码<br>l2tp -l 列出所有用户名和密码<br>l2tp -h 列出帮助信息</p><h6 id="其他事项：">其他事项：<a title="#其他事项：" href="#其他事项："></a></h6><p>1、脚本在安装完成后，已自动启动进程，并加入了开机自启动。<br>2、脚本会改写 iptables 或 firewalld 的规则。<br>3、脚本安装时，会即时将安装日志写到 /root/l2tp.log 文件里，如果你安装失败，可以通过此文件来寻找错误信息。</p><h6 id="使用命令：">使用命令：<a title="#使用命令：" href="#使用命令："></a></h6><p>ipsec status （查看 IPSec 运行状态）<br>ipsec verify （查看 IPSec 检查结果）<br>/etc/init.d/ipsec start|stop|restart|status （CentOS6 下使用）<br>/etc/init.d/xl2tpd start|stop|restart （CentOS6 下使用）<br>systemctl start|stop|restart|status ipsec （CentOS7 下使用）<br>systemctl start|stop|restart xl2tpd （CentOS7 下使用）<br>service ipsec start|stop|restart|status （Debian/Ubuntu 下使用）<br>service xl2tpd start|stop|restart （Debian/Ubuntu 下使用）</p><h6 id="更新日志">更新日志<a title="#更新日志" href="#更新日志"></a></h6><p>2017 年 05 月 28 日：<br>升级 libreswan 到版本 3.20。<br>修正 libreswan 的若干配置问题。<br>修正 xl2tpd 的端口监听配置问题。<br>修正在 CentOS 6 对 libevent2 的依赖问题，改为 yum 安装 libevent2-devel。<br>测试表明，在内网环境的 VPS 里（如AWS， IDCF，GCE，腾讯云，阿里云等）也可以正常使用了。</p><p>2017 年 02 月 25 日：<br>升级 libreswan 到版本 3.19。</p><p>2016 年 09 月 12 日：<br>修正了在 CentOS 6 下 libevent2 依赖的问题；<br>新增了一个 -m 选项，用以修改现有用户的密码。</p><p>2016 年 08 月 13 日：<br>修正 Debian 8 下的 sd-daemon.h: No such file or directory 问题，是由于缺少依赖包 libsystemd-daemon-dev 导致的。</p><p>2016 年 08 月 05 日：<br>升级 libreswan 到版本 3.18。</p><p>2016 年 06 月 10 日：<br>脚本在安装完成后，新增了几个命令，便于操作用户<br>l2tp -a 新增用户<br>l2tp -d 删除用户<br>l2tp -l 列出所有用户<br>l2tp -h 列出帮助信息</p><p>2016 年 04 月 25 日：<br>4、在 Vultr 的 Debian 7的系统模板下安装时，软件包 libcurl4-nss-dev 会出现依赖错误。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line">libcurl4-nss-dev : Depends: libldap2-dev but it is not going to be installed</span><br><span class="line">Depends: librtmp-dev but it is not going to be installed</span><br></pre></td></tr></table></figure><p>而 libldap2-dev 和 librtmp-dev 又依赖了其他几种软件包。总之最后的依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libldap2-dev : Depends: libldap-2.4-2 (&#x3D; 2.4.31-2+deb7u1) but 2.4.31+really2.4.40+dfsg-1+deb8u1~bpo70+1 is to be installed</span><br><span class="line">librtmp-dev : Depends: libgnutls-dev but it is not going to be installed</span><br><span class="line">libgnutls-dev : Depends: libp11-kit-dev (&gt;&#x3D; 0.4) but it is not going to be installed</span><br><span class="line">libp11-kit-dev : Depends: libp11-kit0 (&#x3D; 0.12-3) but 0.20.7-1~bpo70+1 is to be installed</span><br></pre></td></tr></table></figure><p>那么解决办法就是把最底层的依赖包 libp11-kit0 先卸载掉，然后再安装 libcurl4-nss-dev 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y remove libp11-kit0</span><br><span class="line">apt-get -y --no-install-recommends install libcurl4-nss-dev wget</span><br></pre></td></tr></table></figure><p>然后再运行脚本安装即可。</p><p>2016 年 04 月 22 日：<br>修复了在 Ubuntu 16.04 下因为默认缺少 python 命令而导致 ipsec verify 等命令不能用的问题。</p><p>2016 年 04 月 19 日：<br>修复了在 Debian 7 下因为 libnss3 和 libnspr4 的版本过低而导致编译 libreswan 失败的问题。</p><p>2016 年 04 月 18 日：<br>目前在 Debian 7 上测试的结果，因为 libnss3 和 libnspr4 的版本过低而导致编译 libreswan 失败。临时解决办法是 dpkg 安装 libnss3_3.17.2 和 libnspr4_4.10.7 的 deb 包后重试。</p><hr><p>本内容来源于：<a href="https://teddysun.com/448.html">https://teddysun.com/448.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>入手日版Nintendo Switch</title>
      <link href="/2020/01/Nintendo-Switch/"/>
      <url>/2020/01/Nintendo-Switch/</url>
      <content type="html"><![CDATA[<img src="https://images.shiguangping.com/imgs/202001/IMG_5103.JPG" width=600><p>这是我入手的第三台任天堂switch。</p><p>第一台是任天堂刚发布switch不久之后购入的，当时系统还没有简体中文，大多数游戏都没有中文，后来闲鱼出手了。</p><p>第二台是去年吧，被异度之刃2这款游戏的CG吸引了，玩了没多久也卖了。</p><p>前几天一直在为入手NS还是NSL所困扰，后来合计一步到位，以后能在电视上玩，还是买了这台Switch，好像是日版的续航增强版，现在版本真多。</p><p>机器是昨天到的，贴膜是今天上午到的。</p><p>刚刚贴膜的时候膜贴废了，随后又在京东买了张贴膜，还有内存卡，打算明天再重新贴一下。</p><p>最近这几天，在家躲避疫情，重新开始玩玩之前的神作，<em><strong>塞尔达旷野之息</strong></em>。</p><p>之前玩的是日文版的，真心费劲。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nintendo Switch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>退烧键盘-Niz micro82 45g</title>
      <link href="/2019/12/keyboard-niz/"/>
      <url>/2019/12/keyboard-niz/</url>
      <content type="html"><![CDATA[<p>今天提前收到小姐姐送的生日礼物，一把心仪已久的键盘，<em><strong>Niz宁芝静电容键盘（micro82 45g)</strong></em>。</p><p>废话不多说了，上图：</p><p><em>（这手感和声音，爽~）</em></p><p><em><strong>小姐姐说这个键盘按起来像以前上微机课的键盘-。-！</strong></em></p><img src="https://images.shiguangping.com/imgs/201912/20191214_144301.jpg" width="400px"/><p><em>外包装比较简单</em></p><img src="https://images.shiguangping.com/imgs/201912/20191214_144329.jpg" width="400px"/><p><em>键盘本体，这款是82键版本，白灰的键帽配色，很有敲敲敲的欲望。</em></p><p><em>键盘自带了Mac键帽可以替换，还带了几个增压弹簧。</em></p><p><em>键盘采用PBT键帽，用久了也不会出现打油的情况。键盘我还是推荐白色，或者类似白色，干净不易脏，看久了不腻。黑色尤其是ABS键帽，特别不耐脏。</em></p><img src="https://images.shiguangping.com/imgs/201912/20191214_150504.jpg" width="400px"/><p><em>Niz的logo。</em></p><p><em>键盘有些地方有毛边，但也对得起它的价格。和动辄2000多的HHKB比起来，这款键盘的价格相当亲民了。</em></p><img src="https://images.shiguangping.com/imgs/201912/20191214_151002.jpg" width="400px"/><p><em><strong>感谢小姐姐，2019年12月14日。</strong></em></p>]]></content>
      
      
        <tags>
            
            <tag> 静电容 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>与铁蛋儿的“一夜情”</title>
      <link href="/2019/09/cat-tiedar/"/>
      <url>/2019/09/cat-tiedar/</url>
      <content type="html"><![CDATA[<p>铁蛋儿是我昨天晚上捡回来的。</p><p>昨晚在楼下电影院看完<em>郭森斯坦森</em>和<em>巨石强森</em>主演的《速度与激情：特别行动》后回来，在楼下看见了铁蛋儿。</p><p>刚看见铁蛋儿时以为是只野猫，因为小区里的野猫特别多，但是小区的野猫都不近人。铁蛋儿看见我之后，走到我腿边儿蹭，我猜它是饿了。</p><p>随后我就把它勾引回家了。</p><p>回到家我给它水，火腿，吃完东西后给它洗澡，洗澡时有点儿抗拒*（猫咪果然天生不喜欢水）*。</p><p>看它傻头傻脑的样儿，给它取了名字叫<strong>铁蛋儿</strong>，感觉特配它的傻气。</p><img src="https://images.shiguangping.com/typecho/uploads/2019/09/1766375958.jpg " width="400px"/><p><em>（今早儿拍的照片，还把以前买的一直没机会戴的猫铃铛给它戴上了）</em></p><p>当天晚上我到客厅窗边打电话，它就跟着我到了客厅窗台上站着，一动不动。</p><p>我回卧室躺着，它也屁颠儿屁颠儿地跑到床上，过一会儿就在我身边睡着了，伴随着猫咪特有的呼噜声。</p><p>期间它醒了几次，不一会儿又睡着了。</p><img src="https://images.shiguangping.com/typecho/uploads/2019/09/1482629674.jpg" width="400px"/><p>我在床上躺着开始上网查如何养猫，养猫要注意什么？怎么才能不让它破坏家里面的东西，内心纠结着能不能对它的一生付责任。</p><p>早晨起来发现它在我家门口旁的袋子上尿尿了，估计是当成猫砂了。我猜铁蛋儿是有主人的。</p><p>结果今早儿，铁蛋儿的主人就在小区群里发了寻猫启事。</p><p>虽然对铁蛋儿有很多的不舍，但我还是联系了铁蛋儿真正的主人。</p><p>与其我模棱两可的纠结是否收养它，不如把它交给真正对它好的主人身边吧。</p><p>我和铁蛋儿的“一夜情”就这样结束了。</p><p><em>从主人处得知，铁蛋儿是一只约三个多月大的小母猫。</em></p><h2 id="铁蛋儿の写真">铁蛋儿の写真<a title="#铁蛋儿の写真" href="#铁蛋儿の写真"></a></h2><img src="https://images.shiguangping.com/typecho/uploads/2019/09/2867367599.jpg" width="400px"/><img src="https://images.shiguangping.com/typecho/uploads/2019/09/1564673647.jpg" width="400px"/><img src="https://images.shiguangping.com/typecho/uploads/2019/09/833197968.jpg" width="400px"/>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 铁蛋儿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Cloudreve搭建私有云盘</title>
      <link href="/2019/09/cloudreve/"/>
      <url>/2019/09/cloudreve/</url>
      <content type="html"><![CDATA[<h3 id="1.访问官网下载源码">1.访问<a href="https://cloudreve.org/">官网</a>下载源码<a title="#1.访问官网下载源码" href="#1.访问官网下载源码"></a></h3><img src="https://images.shiguangping.com/typecho/uploads/2019/09/1528145123.png" width="400px"/><p><em><strong>下载最新的安装包</strong></em></p><img src="https://images.shiguangping.com/typecho/uploads/2019/09/3690622660.png" width="400px"/><h3 id="2.解压缩并将源码上传至服务器空间">2.解压缩并将源码上传至服务器空间<a title="#2.解压缩并将源码上传至服务器空间" href="#2.解压缩并将源码上传至服务器空间"></a></h3><p>将下载好的安装包解压后，将文件夹内的所有文件全部上传至服务器空间</p><img src="https://images.shiguangping.com/typecho/uploads/2019/09/2470042002.png" width="400px"/><h3 id="3.访问域名导入数据库安装">3.访问域名导入数据库安装<a title="#3.访问域名导入数据库安装" href="#3.访问域名导入数据库安装"></a></h3><p>源码上传至空间后，浏览器访问<code>域名/CloudreveInstaller</code>进行环境检查，配置数据库信息。</p><h3 id="4.登录后台配置相关设置">4.登录后台配置相关设置<a title="#4.登录后台配置相关设置" href="#4.登录后台配置相关设置"></a></h3><p>安装完成后，访问【您的域名/admin】，登录到后台，可修改用户名密码，以及配置所需要的设置等</p><img src="https://images.shiguangping.com/typecho/uploads/2019/09/4131852593.png" width="400px"/><h3 id="5.遇到的问题">5.遇到的问题<a title="#5.遇到的问题" href="#5.遇到的问题"></a></h3><ol><li>头像显示问题，上传头像不显示，可能是服务器PHP没有安装【fileinfo】插件。我用的bt面板，在PHP的安装扩展里安装fileinfo即可。</li><li>不支持文件夹上传，这个不算是问题，我看论坛，开发者目前没有加入文件夹上传这一功能。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 可道云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>根据转载的一篇文章总结的Java学习方法</title>
      <link href="/2018/06/java-learning-method/"/>
      <url>/2018/06/java-learning-method/</url>
      <content type="html"><![CDATA[<h1 id="step-1-学习路线">step 1 学习路线<a title="#step-1-学习路线" href="#step-1-学习路线"></a></h1><p>路线：<em><strong>JavaSE–&gt;web–&gt;Java后端</strong></em></p><h3 id="1.-javase">1. JavaSE<a title="#1.-javase" href="#1.-javase"></a></h3><p>找一个Java基础教程，尽量多动手，对Java有一个基本的了解。</p><h3 id="2.-web开发">2. web开发<a title="#2.-web开发" href="#2.-web开发"></a></h3><p><strong>学习web，学习顺序：</strong></p><ol><li><p>HTML/CSS/JS</p></li><li><p>Servlet/JSP(JAVAEE)</p></li><li><p>Mysql(数据库)</p></li></ol><ul><li><p>首先，要学习<strong>HTML/CSS/JS</strong>，这些东西对于Java后端开发来说，理论上不是特别重要，但至少要达到可以自己写页面的水平。</p></li><li><p>然后，**Servlet/JSP(JAVAEE)**这部分，这部分是Java后端必须必须精通的，这部分也是三部分中最需要花费精力的。</p></li><li><p>最后，学习使用数据库，<strong>Mysql</strong>是不错的入门选择，而且Java领域主流的关系型数据库就是Myqsl。这部分一般在学习<strong>Servlet/JSP</strong>的时候就会接触到，其中JDBC部分就是数据库的相关部分。这部分不仅要学会用JDBC操作数据库，还要学会使用数据库客户端工具，例如：<strong>navicat</strong>，<strong>sqlyog</strong>，二选一即可.</p></li></ul><h3 id="3.-开发框架">3. 开发框架<a title="#3.-开发框架" href="#3.-开发框架"></a></h3><p>学会以上内容还不足以参加工作，为了提高开发效率，会使用一些<strong>Java Web框架</strong>。目前比较主流的是<strong>SSM框架</strong>，即<strong>spring</strong>，<strong>springmvc</strong>，<strong>mybatis</strong>。这里需要学会这三种框架的搭建，并用他们做出一个简单的增删改查项目.</p><p>快速地利用SSM搭建出一个web框架是必须的，记录下第一次的搭建过程是很有必要的。在搭建SSM的过程中，会接触到一个叫<strong>maven</strong>的工具，这个工具是以后工作当中会经常用到的工具。在目前这个阶段，只需要到网上了解一下maven的基本用法即可，更高端的用法会随着工作经验的增加，逐渐接触到的。</p><h3 id="4.-找工作">4. 找工作<a title="#4.-找工作" href="#4.-找工作"></a></h3><p>当完成开发框架的学习以后，就该找工作了。在找工作的同时，不应该停下学习。上面这些内容只是囫囵吞枣的学会了使用，你可以逐步尝试着去了解更多的东西，网络是你最重要的老师。</p><h1 id="step-2-java编程思想,深入理解java基础">step 2 Java编程思想,深入理解Java基础<a title="#step-2-java编程思想,深入理解java基础" href="#step-2-java编程思想,深入理解java基础"></a></h1><p>对于参加工作___1年以内___的同学，恭喜你，这个时候，你已经拥有了一份Java的工作。这个阶段是你成长极快的阶段，而且你可能会经常加班。但是加班不代表你就可以松懈了，永远记得我说的那句话，<em>从你入行那一刻起，你就要不停的学习</em>。</p><p>在这一年里，你至少需要看完**《Java编程思想》**这本书。这本书的内容是帮助你对于Java有一个更加深入的了解，是Java基础的升级版。这本书很厚，当初看这本书，我花了整整三个月。正常速度的话，应该可以在半年左右看完。我这里不要求过高，只要你在一年以内把这本书看完即可。当然了，我所说的看完，是充分吸收，而不是读一遍就完事了，因此有些内容你可能会看不止一遍。总而言之，这个阶段的核心学习思想就是，在工作中实践，并且更加深入的了解Java基础。</p><h3 id="设计模型">设计模型<a title="#设计模型" href="#设计模型"></a></h3><p><strong>对于参加工作1年到2年的同学</strong>，这部分时间段的同学，已经对Java有了一个更加深入的了解。但是对于面向对象的体会可能还不够深刻，编程的时候还停留在完成功能的层次，很少会去考虑设计的问题。于是这个时候，设计模式就来了。我当时看的是**《大话设计模式》**这本书，并且写了完整版的设计模式博客。因此，我要求大家，最多在你工作一年的时候，必须开始写博客，而设计模式就是你博客的开端。</p><p>请记住，我所提的基本都是最低要求，因此不要有任何松懈的心理，否则五年后，你不要去羡慕别人高于你的工资，也不要去羡慕别人进入了某公司。这一年，你必须对于设计模式了如指掌，《大话设计模式》可以作为你的开端。此外，设计模式并不是你这一年唯一的任务，你还需要看一些关于代码编写优化的书。比如**《重构 改善既有代码的设计》<strong>，</strong>《effective java》**。总而言之，这个阶段，你的核心任务就是提高你的代码能力，要能写出一手优雅的代码。</p><h1 id="step-3-参加工作2年到3年的同学">step 3 参加工作2年到3年的同学<a title="#step-3-参加工作2年到3年的同学" href="#step-3-参加工作2年到3年的同学"></a></h1><p><strong>对于参加工作2年到3年的同学</strong>，有的同学在这个时候觉得自己已经很牛逼了，于是忍不住开始慢慢松懈.请记住,你还嫩的多。对这个阶段，有一本书是你必须看的，它叫做**《深入理解Java虚拟机》**。这本书绝对是Java开发者最重要的书，没有之一。在我眼里，这本书的重要性还要高于《Java编程思想》。这本书的内容是帮助你全面的了解Java虚拟机，在这个阶段，你一定已经知道Java是运行在JVM之上的。所以，对于JVM，你没有任何理由不了解它。</p><p>另外，在过去2年的工作当中，你肯定或多或少接触过并发。这个时候，你应该去更加深入的了解并发相关的知识，而这部分内容，我比较推荐**《Java并发编程实战》**这本书。只要你把这本书啃下来了，并发的部分基本已经了解了十之六。与此同时，这个阶段你要做的事情还远不止如此。这个时候，你应该对于你所使用的框架应该有了更深入的了解，对于Java的类库也有了更深入的了解。</p><p>因此，你需要去看一些jdk中的类的源码，也包括你所使用的框架的源码。这些源码能看懂的前提是，你必须对设计模式非常了解。否则的话，你看源码的过程中，永远会有这样那样的疑问，这段代码为什么要这么写？为什么要定义这个接口，它看起来好像很多余？由此也可以看出，这些学习的过程是环环相扣的，如果你任何一个阶段拉下来了，那么你就真的跟不上了，或者说是一步慢步步慢。而且我很负责的告诉你，我在这个阶段的时候，所学习的东西远多于这里所罗列出来的。</p><p>因此千万不要觉得你已经学的很多了，我所说的这些都只是最低要求，不光是我，很多人在这个时间段所学习的内容都远超本文的范围。如果你不能跟上节奏的话，若干年后，如果不是程序猿市场还不错的话，你很可能不仅仅是工资比别人低，公司没别人好，而是根本就找不到工作。总而言之，这个阶段，你需要做的是深入了解<strong>Java底层</strong>和<strong>Java类库</strong>（比如并发那本书就是Java并发包java.concurrent的内容），也就是JVM和JDK的相关内容。而且还要更深入的去了解你所使用的框架，方式比较推荐看源码或者看官方文档。另外，还有一种学习的方式，在2年这个阶段，也应该启用了，那就是造轮子。不要听信那套“不要重复造轮子”的论调，那是公司为了节省时间成本编造出来的。重复造轮子或许对别人没有价值，因为你造的轮子可能早就有了，而且一般情况下你造出来的轮子还没有现存的好。</p><p>但是对别人没有价值，不代表对你自己没有价值。一个造轮子的过程，是一个从无到有的过程。这个过程可以对你进行系统的锻炼，它不仅考察你的编码能力，还考察你的框架设计能力，你需要让你的轮子拥有足够好的扩展性、健壮性。而且在造轮子的过程中，你会遇到各种各样的难题，这些难题往往又是你学习的契机。当你把轮子造好的时候，你一定会发现，其实你自己收获了很多。所以，这个阶段，除了上面提到的了解JVM/JDK和框架源码以外，也请你根据别人优秀的源码,去造一个任何你能够想象出来的轮子。</p><h1 id="step-4-参加工作3年到4年的同学">step 4 参加工作3年到4年的同学<a title="#step-4-参加工作3年到4年的同学" href="#step-4-参加工作3年到4年的同学"></a></h1><p><strong>对于参加工作3年到4年的同学</strong>，这个阶段的同学，提升已经是很难了，而且这个阶段的学习往往会比较多样化。因为在前3年的过程中，你肯定或多或少接触过一些其它的技术，比如大数据、分布式缓存、分布式消息服务、分布式计算、软负载均衡等等。这些技术，你能精通任何一项，都将是你未来面试时巨大的优势，因此如果你对某一项技术感兴趣的话，这个时候可以深入去研究一下。这项技术不一定是你工作所用到的，但一定是相关的。而且在研究一门新技术时，切忌朝三暮四。有的同学今天去整整大数据，搞搞Hadoop/hbase一类的东西。过不了一段时间，就觉得没意思，又去研究分布式缓存，比如redis。然后又过不了一段时间，又去研究分布式计算，比如整整Mapreduce或者storm。结果到最后，搞得自己好像什么都会一样，在简历上大言不惭的写上大数据、分布式缓存、分布式计算都了解，其实任何一个都只是浮于表面。到时候面试官随便一问，就把你给识破了。</p><p>一定要记住，作为一个程序猿，平日里所接触的技术可能会很多，但是想要让一门技术成为你的优势，那么一定是你对这门技术的了解强过绝大多数人才行。因此在这个阶段，你就不能再简单的去学习前3年的内容了，虽然前面的学习如果还不够深入的话依旧要继续，但这个时候你应该更多的考虑建立你的优势，也可以称为差异性。差异性相信不难理解，就是让你自己变得与众不同。你前面三年的学习足够你成为一名基本合格的Java开发者，但你离成为一名优秀的Java开发者还有很大的距离。</p><p>所谓优秀，即能别人所不能。而你前三年所学习的内容，是很多做过几年的Java开发都能够掌握的。那么为了让自己有差异性，你就需要另辟蹊径，找一个方向深入研究下去，以期在将来，你能够成为这个领域的专家，比如分布式计算领域的专家，大数据领域的专家，并发领域的专家等等。此外，你除了建立你的差异性之外，还要去弥补你基础上的不足，直到现在，我都没有提及基础知识。原因是基础是很枯燥无味的，学的太早不仅容易懵逼，而且懵逼的同时还容易产生心理阴影，以至于以后再不想去研究这些基础。但基础又是你深入研究一些领域时所必须掌握的，比如你去研究分布式计算，你不懂算法你玩个毛？比如你去做分布式缓存，你对计算机系统的内存不了解，你如何去做缓存？</p><p>如果你的基础本来就非常强，那么恭喜你，相信你在之前的工作中已经充分体会到了这些基础对你的帮助。但我相信大部分人的基础都很薄弱，哪怕是科班毕业的人，很多人也不敢说自己当初的基础学的多么强大，比如算法、计算机系统原理、编译原理这些。但是每个人时间都是有限的，而且这些基础的书籍每一本读下来，没个一年半载的，还真拿不下来，因此还是要有所抉择的。虽然艺多不压身，但问题是艺多是有代价的，是需要你付出时间和精力的，而我个人更赞成在同等代价的情况下获取最大的收获。</p><p>首先，我比较推崇的基础书籍有三本，分别是**《深入理解计算机系统》<strong>，</strong>《tcp/ip详解 卷一、二、三》<strong>，</strong>《数据结构与算法》**。其中TCP/IP有三本书，但我们这里把这三本看成是一本大书。这三本分别适合三种人，《深入理解计算机系统》比较适合一直从事Java Web开发和APP后端开发工作的人群。《tcp/ip详解 卷一、二、三》比较适合做网络编程的人群，比如你使用netty去开发的话，那么就要对TCP/IP有更深入的了解。而《数据结构与算法》这本书，则比较适合做计算研究工作的人，比如刚才提到的分布式计算。另外，我要强调的是，这里所说的适合，并不是其它两本对你就没有用。比如你做Java Web和APP后端开发，《tcp/ip详解 卷一、二、三》这本书对你的作用也是很大的。这里只是分出个主次关系而已，你要是时间足够的话，能把三本都精读那当然最好不过了。</p><p>但如果时间有限的话，那么就先挑对你帮助最大的书去读。理论上来讲，这一年你能把这三本其中一本精读下来，就已经非常厉害了。有了基础，有了前面的工作经验，你就可以去开拓属于你的领域了。在这一年里，一定要规划好自己的领域，建立好自己的优势，制造出差异性。如果你对自己的领域不够清晰的话，随着你工作的时间日益增多，你接触的技术会越来越多，这个时候，你很容易被淹死在技术的海洋里，看似接触的技术越来越多，会用的也越来越多，但你毫无优势。有的同学可能会问，“我，我也不知道我的领域是什么啊？怎么办呢？”对于这种人，我只想说，“卧槽，这还问我？要不干脆我替你学习得了，好不好？”</p><h1 id="step-5-参加工作4年到5年的同学">step 5 参加工作4年到5年的同学<a title="#step-5-参加工作4年到5年的同学" href="#step-5-参加工作4年到5年的同学"></a></h1><p><strong>对于参加工作4年到5年的同学</strong>，经过前面一年的历练，相信你在自己所钻研的领域已经有了自己一定的见解，这个时候，技术上你应该已经遇到瓶颈了。这个时候不要着急提高自己的技术，已经是时候提高你的影响力了，你可以尝试去一些知名的公司去提高你的背景，你可以发表一些文章去影响更多的人。当然，你也可以去GitHub创建一个属于你的开源项目，去打造自己的产品。</p><p>这次的开源项目不同于之前的造轮子，你这个时候是真的要去尽量尝试造出来真正对别人有价值的轮子。技术学到这个阶段，很容易遇到瓶颈，而且往往达到一定程度后，你再深入下去的收效就真的微乎其微了，除非你是专门搞学术研究的。然而很可惜，大部分程序猿做不到这一步，那是科学家做的事情。这个时候提高影响力不仅仅是因为技术上容易遇到瓶颈，更多的是影响力可以给你创造更多的机会。程序猿在某种程度上和明星很像，一个好的电视剧和电影就可以成就一批明星，程序猿有的时候也是，一个好的项目就可以成就一群程序猿。比如国内几个脍炙人口的项目，像淘宝、支付宝、QQ、百度、微信等等。这每一个项目，都成就了一批程序猿。我敢说，这里面任何一个项目，如果你是它的核心开发，光是这样一个Title，就已经是你非常大的优势。更何况还不止如此，Title说到底也是个名头，更重要的是，这种项目在做的时候，对你的历练一定也是非常给力的。</p><p>而你如果想要参与这样的项目，除了靠运气之外，影响力也是很重要的一个手段。比如你在分布式计算领域有一定的影响力，那么如果有什么好的关于分布式计算的项目，对方就很可能会邀请你。就算人家不邀请你，你自己主动去面试的时候，对方如果知道你在这个领域的影响力，也肯定会起到很大的作用，而这个作用，甚至可能会超过你现在的技术能力。所以，在这个阶段，你最大的任务是提高自己的影响力，为自己未来的十年工作生涯那一天做准备。如果你能够靠你的影响力和以前积累的技术，参与到一个伟大的项目当中，那么你后面的五年也就有着落了。当然了，我现在满打满算，做程序猿也就4年半不到，因此关于4年到5年这一部分，我的见解不一定是对的，就算是对的，也不一定是适合任何人的。</p><p>所以，希望大家自己有的判断力，去决定到底该如何度过这一年。</p><h1 id="结语">结语<a title="#结语" href="#结语"></a></h1><p>本文到此就基本结束了，整篇文章很长，但其实主要就说了两部分内容，一个是社招面试的准备，一个是Java生涯的学习。关于这两部分，我已经给出了自己的见解，但是还是那句话，每个人吸收知识的时候，都要有抽取精华，去除糟粕的能力。我所说的，可能有些是对的，有些是错的，有些是适合你的，有些是不太适合你的，你要自己能够判断。其实你在生活和工作当中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你很讨厌。但其实你喜欢的人也有缺点，你讨厌的人也有优点。你要学会从你讨厌的人身上学会他的优点，千万不要一棒子打死，这只会让你失去很多学习成长的机会。好了，说了这么多了，就到此为止吧，希望本文可以帮助到作为程序猿或即将成为程序猿的你。</p><p><strong>声明</strong>：<em>本文转载自网络，<a href="http://www.cnblogs.com/huaxingtianxia/p/5724093.html" target="_blank">原文地址</a>。</em></p><p><em>这篇文章发表自2016年，距离现在已经过了很长一段时间。可能再过一段时间，会出现更多的技术，学习路线可能也会发生改变。但是这篇文章的一些想法和思路是非常值得借鉴和学习的。—2018年6月17日</em></p><p><em>整理博客时，又看到了这篇文章。这回正式决心杀进程序猿行业，拿出半年时间培训，最后一次机会，来之不易，成本颇大，规划好学习路线，必须比其他人掌握的更多，才能多一份机会。我发现培训机构的同学是真心都学习啊，课堂气氛太活跃了。—2020年4月20日</em></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux的几个有趣命令</title>
      <link href="/2018/06/linux-funny-commond/"/>
      <url>/2018/06/linux-funny-commond/</url>
      <content type="html"><![CDATA[<h4 id="sl命令">sl命令<a title="#sl命令" href="#sl命令"></a></h4><p>你会看到一辆小货车从屏幕右边开到了左边～</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install sl</span><br><span class="line">运行：sl</span><br></pre></td></tr></table></figure><h4 id="fortune命令">fortune命令<a title="#fortune命令" href="#fortune命令"></a></h4><p>输出一句话，有笑话、名言、唐诗宋词等等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install fortune</span><br><span class="line">运行：fortune</span><br></pre></td></tr></table></figure><h4 id="cowsay命令">cowsay命令<a title="#cowsay命令" href="#cowsay命令"></a></h4><p>用ASCII字符打印牛、羊等动物。还有<code>cowthink</code>命令，这是是奶牛想，命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install cowsay</span><br><span class="line">运行：cowsay -f tux &quot;坑爹啊～&quot;</span><br><span class="line"></span><br><span class="line">cowsay -l    查看其他动物的名字</span><br><span class="line">cowsay -f 动物们 &quot;坑爹啊～&quot;    可其他动物</span><br></pre></td></tr></table></figure><h4 id="cmatrix命令">cmatrix命令<a title="#cmatrix命令" href="#cmatrix命令"></a></h4><p>这个是《黑客帝国》里面的代码雨，很cool：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install cmatrix</span><br><span class="line">运行：cmatrix</span><br></pre></td></tr></table></figure><p>使用<code>Ctrl+C</code>程序结束。</p><h4 id="figlet、toilet命令">figlet、toilet命令<a title="#figlet、toilet命令" href="#figlet、toilet命令"></a></h4><p>艺术字生成器，由ASCII字符组成，把文本显示成标题栏。此外还有banner这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install figlet</span><br><span class="line">    sudo apt-get install toilet</span><br><span class="line">运行：figlet I LOVE YOU !</span><br><span class="line">    toilet I LOVE YOU !</span><br></pre></td></tr></table></figure><p>此外<code>toilet</code>还可以添加颜色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toilet -f mono -F gay I LOVE YOU !</span><br></pre></td></tr></table></figure><h4 id="oneko命令">oneko命令<a title="#oneko命令" href="#oneko命令"></a></h4><p>这个也比较有趣，桌面上出现一只喵星人，会跟着你的鼠标再跑，<code>Ctrl+C</code>结束：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo apt-get install oneko</span><br><span class="line">运行：oneko</span><br></pre></td></tr></table></figure><h4 id="yes命令">yes命令<a title="#yes命令" href="#yes命令"></a></h4><p>一直输出字符，使用<code>Ctrl+C</code>结束：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes I LOVE YOU !</span><br></pre></td></tr></table></figure><h4 id="cal命令">cal命令<a title="#cal命令" href="#cal命令"></a></h4><p>这个是打印日历：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal 6 2018</span><br></pre></td></tr></table></figure><h1 id="结尾">结尾<a title="#结尾" href="#结尾"></a></h1><p>这些命令是在今日头条看到的，很有趣。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>在Linux中使配置alias永久生效</title>
      <link href="/2018/06/alise-linux/"/>
      <url>/2018/06/alise-linux/</url>
      <content type="html"><![CDATA[<h3 id="编辑.bashrc">编辑.bashrc<a title="#编辑.bashrc" href="#编辑.bashrc"></a></h3><p>在终端，通过命令回家：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>之后通过文本编辑器编辑文本<code>.bashrc</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit .bashrc</span><br></pre></td></tr></table></figure><p>或者，使用vim编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim .bashrc</span><br></pre></td></tr></table></figure><p>如果没有<code>.bashrc</code>文件，需要手动创建一个。</p><p><em>注意：<code>.bashrc</code>是隐藏文件，在文件管理器中查看时需要勾选<code>显示隐藏文件</code>。</em></p><p>创建好之后，在<code>.bashrc</code>最后一行添加你要设置的alias命令，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias hxc=&#x27;rm -f ~/blog/db.json &amp;&amp; hexo clean&#x27;</span><br></pre></td></tr></table></figure><p>如果是新建的<code>.bashrc</code>文件，直接在里面添加alias命令就可以，命令是一行一行的。</p><p>添加完之后保存，再通过source命令使刚才的配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>之后在终端敲击<code>alias</code>命令，查看刚刚配置的alias命令是否生效。</p><h3 id="编辑.bash_profile">编辑.bash_profile<a title="#编辑.bash_profile" href="#编辑.bash_profile"></a></h3><p>在<code>.bash_profile</code>最后一行添加一条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p><em>注意：如果没有<code>.bash_profile</code>文件就新建一个。</em></p><p>添加完之后保存退出，终端通过source命令使配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>此时可以重新打开终端，输入<code>alias</code>命令，查看配置的alias是否已经生效。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo上传本地源文件到GitHub</title>
      <link href="/2018/06/hexo-local-source/"/>
      <url>/2018/06/hexo-local-source/</url>
      <content type="html"><![CDATA[<h1 id="前言(可忽略不看)">前言(可忽略不看)<a title="#前言(可忽略不看)" href="#前言(可忽略不看)"></a></h1><p>这个问题是在我部署完HEXO博客之后就想到的，我要是换了一台电脑或者重新装系统之后，还怎么更新HEXO博客呢？</p><p>我今天在网上开始寻找解决办法，上网一看才知道这是很多人很早以前就面临的问题，当然有很多大神做了解答，但是绝大多数的回答我都是看不懂的。大多数的办法是在同一个GitHub仓库创建两个分支，一个用来存放HEXO上传的静态页面，一个用来保存HEXO的本地源文件。但是对于我这个小白来说，仓库一词我都是最近才知道的，更别提分支了。还有一大堆的命令，我也看不懂所以然。</p><p>最后，我还是用了这个办法，在原有的仓库基础上再创建一个分支，用来保存本地的源文件。（网上主要的还是这个办法）</p><p>我试着把我的操作流程写下来，可能其中会有遗漏或者小错误，遇到问题只能自己解决了。因为我也是凭借自己理解操作的。</p><h1 id="我为什么要把源文件上传到github呢？">我为什么要把源文件上传到GitHub呢？<a title="#我为什么要把源文件上传到github呢？" href="#我为什么要把源文件上传到github呢？"></a></h1><p>因为我今天在电脑上安装了Linux，所以以后敲字都要靠Linux了。</p><h1 id="一.本地源文件上传到github：">一.本地源文件上传到GitHub：<a title="#一.本地源文件上传到github：" href="#一.本地源文件上传到github："></a></h1><h2 id="1.提前准备">1.提前准备<a title="#1.提前准备" href="#1.提前准备"></a></h2><p>首先，不论是在另一台电脑上还是重新安装了系统，都要安装好Node.js和Git，还有HEXO，它们的安装方式具体参考HEXO的<a href="https://hexo.io/zh-cn/docs/" target="_blank">说明文档</a>。</p><h2 id="2.操作流程">2.操作流程<a title="#2.操作流程" href="#2.操作流程"></a></h2><p>1.登录到GitHub，打开hexo所在的仓库，在博客所在的repository新建一个分支<strong>hexo</strong>，在仓库Setting下的Branches中，设置<strong>hexo</strong>为默认分支。<br>2.克隆repository到本地，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@github.com:ENNRIaaa/shiguangping-blog.git</span><br></pre></td></tr></table></figure><p>注：克隆的文件夹保存在哪取决于你所在的位置，可通过pwd命令查看你当前所在位置。<br>3.克隆好之后，打开本地的文件夹，默认的文件夹名字就是repository的名字，把文件夹内除了**.git<strong>文件夹之外的所有文件全部删除。注意：</strong>.git<strong>是隐藏文件夹。<br>4.之后把原电脑上的HEXO文件全部复制到这个文件夹下。<br>5.复制完之后里面应该有一个名为</strong>.gitignore**文件，如果没有的话通过终端命令创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>正常**.gitignore**的内容是：</p><ul><li><p>.DS_Store</p></li><li><p>Thumbs.db</p></li><li><p>db.json</p></li><li><p>*.log</p></li><li><p>node_modules/</p></li><li><p>public/</p></li><li><p>.deploy*/</p></li></ul><p>6.切换到<strong>hexo</strong>分支上，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>7.提交复制过来的文件到<strong>暂存区</strong>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><p>8.提交，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;新建分支资源文件&quot;</span><br></pre></td></tr></table></figure><p><em>引号内的内容自定义，就是一个备注。</em><br>9.推送分支到GitHub上，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>推送成功之后，到GitHub仓库刷新一下，看看<strong>hexo</strong>分支下是否已经成功上传了本地的源文件。<br>到这里，本地的源文件已经上传到GitHub上，HEXO本地源文件直接使用<code>git push</code>命令就可以了，HEXO发博客的操作跟以前一样，还是这三步：<code>hexo c</code>、<code>hexo g</code>、<code>hexo d -g</code>。</p><p><em>注：期间终端可能会提示需要输入一下密码啊，或者提示让你输入邮箱和用户名等，只需根据提示输入即可。<br>在安装完Git和node.js之后，我就把SSH密钥配置完了。设置GitHub的SSH密钥，可参考<a href="https://sora.red/2018/GitHub%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AESSH/" target="_blank">GitHub如何配置SSH</a>。</em></p><h1 id="二.如果今后换电脑该如何操作">二.如果今后换电脑该如何操作<a title="#二.如果今后换电脑该如何操作" href="#二.如果今后换电脑该如何操作"></a></h1><p>本地源文件保存到GitHub之后，今后在其他电脑上或者重装系统后，先把<code>Git</code>、<code>Node.js</code>、<code>HEXO</code>这些基本的都安装好,（<em>注意：<strong>Hexo</strong>安装好之后不要执行<code>hexo init</code>初始化命令</em>），再把GitHub上保存HEXO源文件的<strong>hexo</strong>分支克隆到本地即可。<br>克隆分支的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b hexo git@github.com:ENNRIaaa/shiguangping-blog.git</span><br></pre></td></tr></table></figure><p><code>-b</code>后面的是分支的名称，后面替换自己仓库的链接。</p><h1 id="结尾">结尾<a title="#结尾" href="#结尾"></a></h1><p>今天主要提供帮助的是CSDN博主LeonWuV,如果我的文章有一些地方看不懂，或者有错误，可参考<a href="https://blog.csdn.net/wxl1555/article/details/79293159" target="_blank">此博主的文章</a>。<br>本文写了一个多小时，终于结束了。虽然很墨迹，但是很快乐。</p>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitHub如何配置SSH</title>
      <link href="/2018/06/github-ssh/"/>
      <url>/2018/06/github-ssh/</url>
      <content type="html"><![CDATA[<h2 id="一、生成ssh-key">一、生成SSH Key<a title="#一、生成ssh-key" href="#一、生成ssh-key"></a></h2><p>在Git Bash终端输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;china_liyan123@yahoo.co.jp&quot;</span><br></pre></td></tr></table></figure><p><em>此处邮箱替换为自己的邮箱地址。</em></p><p>此时终端提示：</p><blockquote><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/shado/.ssh/id_rsa):</p></blockquote><p>终端会让你选择存放SSH的路径，括号内的是默认路径。</p><p>直接回车选择默认路径，终端提示输入SSH密码，需要输入两次，此时输入的密码不会显示在终端上，敲完接回车即可。</p><blockquote><p>Your identification has been saved in /c/Users/shado/.ssh/id_rsa.<br>Your public key has been saved in /c/Users/shado/.ssh/id_rsa.pub.</p></blockquote><p>之后终端提示密钥已经生成，在刚才选择的默认路径中，其中<code>id_rsa</code>是私有密钥，<code>id_rsa.pub</code>是公共密钥。</p><h2 id="二、在github中添加密钥">二、在GitHub中添加密钥<a title="#二、在github中添加密钥" href="#二、在github中添加密钥"></a></h2><p>登陆GitHub，在页面右上角头像选择下拉菜单中<code>Setting</code>，在设置页面<code>SSH and GPG keys</code>标签页，在这个标签页下添加SSH。</p><p>点击页面右上角<code>New SSH key</code>按钮，添加SSH密钥。</p><p>打开保存SSH的默认路径，打开<code>id_rsa.pub</code><em>（用任意文本编辑器打开即可）</em>，复制里面的内容，粘贴到<code>New SSH key</code>的key里面，Title自定义即可，之后点击Add。</p><p>回到终端窗口，敲入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>此时终端提示：</p><blockquote><p>Enter passphrase for key ‘/c/Users/shado/.ssh/id_rsa’:</p></blockquote><p>输入之前设置的密码，输入时密码不会显示在终端上。</p><p>密码输入正确后，终端会提示：</p><blockquote><p>Hi ENNRIaaa! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>说明SSH密钥已经配置成功。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>小白部署HEXO到GitHub</title>
      <link href="/2018/06/build-hexo/"/>
      <url>/2018/06/build-hexo/</url>
      <content type="html"><![CDATA[<h1 id="前言">前言<a title="#前言" href="#前言"></a></h1><p>呃，终于忙乎完了!</p><p>从昨天傍晚的7点半一直到现在的2点50分，并且到目前都还在折腾，这也是第一篇文章，即将要上传到GitHub上的。</p><p>之前我是没有接触过GitHub和HEXO的，我现在在用的博客程序是z-blog，它部署在腾讯云，地址是：<a href="https:www.shiguangping.com">时光瓶</a>,现在之所以搞hexo，是因为看到了一位前端大咖的博客，<a href="https://diygod.me/" target="_blank">diygod.me</a>，看到之后很惊艳，由此认识到了hexo和GitHub。<br>通过维护这个博客开始我的学习之旅，慢慢了解GitHub，了解开源世界。</p><p>然后说一下现在正在用的这个HEXO主题，这个主题是像素风格的，很有魔性，所以就采用了。在此感谢主题的作者，作者的博客有关于这个主题的说明，虽然我看作者已经很久没有更新他的博客了，<a href="http://blackshow.me/" target="_blank">主题作者</a>.</p><h1 id="开始搭建">开始搭建<a title="#开始搭建" href="#开始搭建"></a></h1><h1 id="1.-本地安装hexo">1. 本地安装HEXO<a title="#1.-本地安装hexo" href="#1.-本地安装hexo"></a></h1><p>安装步骤可以参考官方文档，<a href="https://hexo.io/zh-cn/docs/" target="_blank">中文地址</a>。</p><h3 id="安装前提">安装前提<a title="#安装前提" href="#安装前提"></a></h3><ul><li><p><a href="http://nodejs.org/" target="_blank">Node.js</a>（Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本）</p></li><li><p><a href="http://git-scm.com/" target="_blank">Git</a></p><p><em>这两个是安装Hexo之前必须要安装的</em></p></li></ul><h3 id="安装hexo">安装Hexo<a title="#安装hexo" href="#安装hexo"></a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完Hexo之后，执行下列命令，Hexo会在指定文件夹新建所需文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><em>每个文件的作用请参考官方文档，文档包含详细的安装和配置步骤。</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>启动服务，默认情况下，使用浏览器访问地址://localhost:4000/，如果这个地址无效，可通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure><p>-p 指定端口，重新尝试。如果可以正常访问，页面正常，说明本地配置OK。</p><h1 id="2.-下载和安装主题">2. 下载和安装主题<a title="#2.-下载和安装主题" href="#2.-下载和安装主题"></a></h1><p>我使用的主题是<a href="http://blackshow.me" title="blackshow" target="_blank">blackshow</a>编写的开源主题，该主题基于Freemind修改，样式替换为BOOTSTR.386.作者的博客里有提到。</p><ol><li>安装主题：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:blackshow/hexo-theme-freemind.386.git themes/freemind</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 hexo-tag-bootstrap （可选）:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-bootstrap --save</span><br></pre></td></tr></table></figure><ol start="3"><li>安装 hexo-generatr-search （可选）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><ol start="4"><li>创建页面：<br>Freemind 预先定义了 Categories（分类）、Tags（标签） 和 About（关于）页面，要使用它们，你需要先在你的博客的 <code>source</code> 目录中添加相应页面。<br>例如，要创建 <code>Categories</code> 页面，在终端上:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/hexo/</span><br><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure><p>然后编辑 <code>source/categories/</code> 下的 <a href="http://index.md">index.md</a>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: Categories</span><br><span class="line">layout: categories</span><br></pre></td></tr></table></figure><ol start="5"><li>关于主题的配置和一些相关问题，具体请参考主题作者的<a href="http://blackshow.me/2015/11/25/hexo-theme-freemind-386-readme-cn/" title="说明" target="_blank">说明文档</a>和原作者关于Freemind的<a href="http://www.hahack.com/codes/hexo-theme-freemind/" title="说明文档" target="_blank">说明文档</a>。</li><li>每一步如果想预览，使用一下命令，通过浏览器预览访问本地预览：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="3.-把本地hexo部署到github">3. 把本地Hexo部署到GitHub<a title="#3.-把本地hexo部署到github" href="#3.-把本地hexo部署到github"></a></h1><ol><li>注册GitHub帐号，然后登陆。</li><li>在GitHub新建一个repository，页面的右上角有个加号，里面的New repository<br>这里的Repository Name要和前面的Owner名字相同，<a href="http://xn--ENNRIaaa-6p6ol3uk7uksf0bu213aio1e.github.io">格式就是这样的ENNRIaaa.github.io</a>，ENNRIaaa就是我的Owner名字，然后选择public，创建就可以了。</li><li>编辑HEXO目录下的站点配置文件<code>_config.yml，</code>在最下面加上几行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">      type: git</span><br><span class="line">      repository: https:&#x2F;&#x2F;github.com&#x2F;ENNRIaaa&#x2F;ENNRIaaa.github.io.git</span><br><span class="line">      branch: master</span><br></pre></td></tr></table></figure><p><em>把地址替换为自己GitHub库的地址</em></p><p>然后在终端一次敲如命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean //清除public文件</span><br><span class="line">hexo g //生成静态文件</span><br><span class="line">hexo d -g //把html静态文件推送到GitHub</span><br></pre></td></tr></table></figure><p>此时可能会提示输入GitHub的用户名和密码。我看网上有教程说此步骤需要配置SSH，这个由于我没有配置，也不太懂，所以不多说明。<em>（后续会写如何配置SSH）</em></p><p>本地文件上传到GitHub之后，访问刚才的<strong><a href="http://ENNRIaaa.github.io">ENNRIaaa.github.io</a></strong>，看看是否能正常访问到你的博客。</p><h1 id="4.-绑定个人域名">4. 绑定个人域名<a title="#4.-绑定个人域名" href="#4.-绑定个人域名"></a></h1><p>如果你不需要绑定个人域名，可以忽略这一步，博客可直接通过ENNRIaaa.github.io访问。</p><ol><li>在你域名的解析页面添加解析，我是添加的CNAME，<a href="http://xn--ENNRIaaa-tq0qo72ai87b4q9b.github.io">直接解析ENNRIaaa.github.io</a>，有的人添加的A记录解析的博客的IP地址。</li><li>在刚刚创建的GitHub的repository，选择Setting标签页，在下面的GitHub Pages里面有Custom domain，填上你的域名，Save就可以了。如果没有Custom domain，那就把GitHub Pages下的Source改为master branch。</li><li>在访问绑定的域名，看看是否能正常访问到博客。</li></ol><h1 id="关于新建文章">关于新建文章<a title="#关于新建文章" href="#关于新建文章"></a></h1><p>新建文章需要使用markdown文档编辑工具，我使用的是Typora，支持win/mac平台，编辑时所见即所得。</p><p>文章的头部通过这几个标签来定义标题，日期，描述，分类，标签等…（具体只能靠自己摸索）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: 小白部署HEXO到GitHub</span><br><span class="line">date: 2018-06-10 02:38:31</span><br><span class="line">description: 从傍晚到凌晨，HEXO和GitHub摸索中</span><br><span class="line">categories: 生活随笔</span><br><span class="line">tags: [hexo,GitHub]</span><br><span class="line">toc: true</span><br><span class="line">feature:</span><br></pre></td></tr></table></figure><h1 id="总结">总结<a title="#总结" href="#总结"></a></h1><p>我从昨晚一直折腾到今天早晨，很累。</p><p>本文搭建流程都靠记忆，因为之前没有接触过这些，我也不是编程工作者，所以很多都是通过google一点一点地查，遇到问题的时候，网上给出的答案也是很零散的。</p><p>我写的这个流程可能也有一些错误或者失误的地方，遇到问题只能自己摸索了。</p><ol><li>关于命令以及配置文件.yml对格式的要求很严谨，例如:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br></pre></td></tr></table></figure><p><em>冒号：和后面的git之间都要有空格。</em></p><ol start="2"><li>每次写完文章，上传到GitHub之前都要：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c --删除public文件夹</span><br><span class="line">hexo g --生成静态文件</span><br><span class="line">hexo d -g --上传到GitHub仓库</span><br></pre></td></tr></table></figure><ol start="3"><li>关于上面三个命令可参照主题作者的<a href="http://blackshow.me/2015/11/30/hexo-cheats/" target="_blank">HEXO使用心得</a>这篇文章。</li></ol><p>关于搭建和使用hexo，可以看看主题<a href="http://blackshow.me" target="_blank">作者的博客</a>，他有几遍文章专门是介绍说明HEXO的使用的，很有帮助。</p><ol start="4"><li>每次上传到GitHub之后，访问绑定的域名可能会遇到404页面，解决办法是到repository的Setting–&gt;GitHub Pages重新设置域名，再到本地hexo目录下的source，添加一个名为CNAME的文件，文件内容是自己绑定的域名，问题解决。不会新建文件的可通过新建文本文档命名为CNAME，然后编辑内容，之后保存，再删除掉该文档的后缀即可，即删除.txt。</li></ol><hr><p>本文到此结束。</p>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决Linux中eclipse导入Windows项目后出现中文乱码问题</title>
      <link href="/2018/05/eclipse-text-encoding/"/>
      <url>/2018/05/eclipse-text-encoding/</url>
      <content type="html"><![CDATA[<p>我今天遇到这个问题，在百度问了一遍，大多数的方法都不行</p><p>最后一个人给出的方法解决了这个问题</p><img src="https://images.shiguangping.com/images/linux%20eclipse%E5%AF%BC%E5%85%A5windows%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E5%9B%BE1.png" width="500px"/><p>我在linux下的eclipse导入windows的工程文件后，会出现这样的乱码问题。</p><p>网上说，windows的中文编码方式是GBK，而linux采用的中文编码方式是UTF-8</p><p>所以把linux的编码方式改一下就可以了。</p><p>在出现乱码的文件，键盘敲入 alt+Enter，会出现一个对话框</p><img src="https://images.shiguangping.com/images/linux%20eclipse%E5%AF%BC%E5%85%A5windows%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E5%9B%BE2.png " width="500px"/><p>在下面的Text file encoding，Other里面直接输入GBK，然后应用，这时正常的中文就回来了。</p><img src="https://images.shiguangping.com/images/linux%20eclipse%E5%AF%BC%E5%85%A5windows%E5%B7%A5%E7%A8%8B%E5%90%8E%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/%E5%9B%BE3.png " width="500px"/><p><strong>感谢这个大神</strong></p>]]></content>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux学习之~ubuntu安装jdk及配置环境变量</title>
      <link href="/2018/05/ubuntu-java-path/"/>
      <url>/2018/05/ubuntu-java-path/</url>
      <content type="html"><![CDATA[<h3 id="1.-下载jdk">1. 下载jdk<a title="#1.-下载jdk" href="#1.-下载jdk"></a></h3><p>前往jdk官网下载jdk，地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE1.png" alt="请输入图片描述" class="φcx"></p><p>现在已经更新到jdk10了，但是我下载解压之后发现里面没有jre文件夹，不知为何。为了不发生同样的问题，推荐下载之前的版本。</p><p><em>（文章具有一定的时效性，不代表之后也会出现同样问题）</em></p><p><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE2.png" alt="请输入图片描述" class="φcx"></p><p>我下载的是linux x64的版本，jdk-8u172-linux-x64.tar.gz</p><p>ubuntu系统的话，默认会下载到“下载”里面（我用的ubuntu版本是18.04LTS）</p><h3 id="2.-创建文件夹，将jdk解压到该文件夹内">2. 创建文件夹，将jdk解压到该文件夹内<a title="#2.-创建文件夹，将jdk解压到该文件夹内" href="#2.-创建文件夹，将jdk解压到该文件夹内"></a></h3><ol><li>进到/usr/lib/文件夹下，</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib</span><br></pre></td></tr></table></figure><p><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE3.png" alt="请输入图片描述" class="φcx"></p><p>在当前文件夹输入sudo mkdir jvm创建文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir jvm</span><br></pre></td></tr></table></figure><p>此时可以用命令查看文件夹是否创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>看看是否有jvm这个文件夹。<br><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE4.png" alt="请输入图片描述"></p><ol start="2"><li>然后利用cd命令回到“下载”文件夹，把下载好的jdk移动到刚刚创建的jvm文件夹</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv jdk-8u172-linux-x64.tar.gz /usr/lib/jvm</span><br></pre></td></tr></table></figure><p>然后进入/usr/lib/jvm文件夹，查看该文件是否存在</p><ol start="3"><li>用tar -zxvf命令解压</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf jdk-8u172-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>解压完成后可以用ls -l命令查看是否解压成功</p><p><em>（注：在2步骤时，可以在下载文件夹直接将下载好的jdk解压到目标目录/usr/lib/jvm里，然后在回到jvm目录查看是否解压成功）</em></p><p>也可以直接通过命令解压到指定文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf jdk-8u172-linux-x64.tar.gz -C /usr/lib/jvm</span><br></pre></td></tr></table></figure><h3 id="3.-配置环境变量">3. 配置环境变量<a title="#3.-配置环境变量" href="#3.-配置环境变量"></a></h3><p>编辑.bashrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE5.png" alt="请输入图片描述" class="φcx"></p><p>在结尾fi后面加上这四段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_171</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p><em>第一行JAVA_HOME是jdk的安装路径，这里一定不要写错。</em></p><p>编辑保存之后，在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>使.bashrc生效，如果提示权限问题，在命令前面加上sudo</p><h3 id="4.-安装完成，验证java是否配置完成">4. 安装完成，验证java是否配置完成<a title="#4.-安装完成，验证java是否配置完成" href="#4.-安装完成，验证java是否配置完成"></a></h3><p>在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://images.shiguangping.com/images/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B~ubuntu%E5%AE%89%E8%A3%85jdk%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/%E5%9B%BE6.png" alt="请输入图片描述" class="φcx"></p><p>终端出现java的版本号信息，说明jdk环境变量配置成功。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>JDK安装及配置环境变量</title>
      <link href="/2018/04/java-build-path/"/>
      <url>/2018/04/java-build-path/</url>
      <content type="html"><![CDATA[<p>Java开发需要安装JDK（Java开发工具），JDK里面包括Java编译器，和JRE（Java运行时环境），其中JRE里面又包含JVM（Java虚拟机）、Java核心类库以及相关支持文件。</p><p>所以，在开发Java程序之前，必须先安装JDK。<em>（只为了运行Java程序，只需安装JRE即可）</em></p><h3 id="1.-下载jdk及安装">1. 下载JDK及安装<a title="#1.-下载jdk及安装" href="#1.-下载jdk及安装"></a></h3><p>访问<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">Oracle官方下载地址</a>下载所需的JDK版本。</p><p>下载好的安装包是.exe可执行文件，直接双击下一步即可，安装路径推荐默认。</p><img src="https://images.shiguangping.com/images/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85_%E5%9B%BE1.png" width="400px"/><h3 id="2.-配置环境变量">2. 配置环境变量<a title="#2.-配置环境变量" href="#2.-配置环境变量"></a></h3><p>JDK安装完成之后，就需要给系统配置Java环境变量了。</p><img src="https://images.shiguangping.com/images/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85_%E5%9B%BE2.png" width="400px"/><p>配置环境变量是在：桌面计算机右键属性–&gt;高级系统设置–&gt;环境变量</p><p>编辑上图中<strong>系统变量</strong>中的Path，把JDK的路径地址加入到Path中。</p><p><em>(配置环境变量目的是让操作系统知道JDK)</em></p><p>JDK的默认安装路径一般在C盘下Program Files --&gt;Java文件夹下，参考下图。</p><p><em>（路径一定要全，复制到jdk文件夹下的bin文件夹）</em></p><img src="https://images.shiguangping.com/images/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85_%E5%9B%BE3.png" width="450px"/><p>把这个路径粘贴到系统变量的Path中，每个路径之间用“ ; ”隔开，<em>注意：分号是英文输入状态下的.</em></p><p>编辑确定之后，在cmd窗口敲入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><img src="https://images.shiguangping.com/images/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B_%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85_%E5%9B%BE5.png" width="400px"/><p>终端提示Java版本号，说明环境变量配置成功。</p><p>也可以在cmd里敲javac或java，这时说明java环境变量已经配置成功了。</p><p><em>如果没有配置成功，终端会显示【不是内部或外部命令，也不是可运行的程序或批处理文件】。</em></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK安装 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
